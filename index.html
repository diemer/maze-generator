<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Maze generator</title>
  <style type="text/css">
    body {
      font-family:
        -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans,
        Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      margin: 0 1em 1em;
    }

    p label,
    .color-picker label {
      width: 10em;
      display: inline-block;
    }

    p.desc {
      font-size: smaller;
      border-top: 1px solid #afafaf;
      padding-top: 1em;
    }

    #download {
      display: inline-block;
      padding: 5px 1em;
      font-size: 0.9em;
      background: #3377ff;
      color: #fff;
      border: 0 none;
      cursor: pointer;
      border-radius: 5px;
      text-decoration: none;
    }

    #download:hover {
      background: #0055ff;
    }

    .hide {
      display: none;
    }

    /* Password protection overlay */
    .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #1a1a2e;
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .password-overlay.hidden {
      display: none;
    }

    .password-box {
      background: #fff;
      padding: 2em;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      text-align: center;
      max-width: 300px;
    }

    .password-box h2 {
      margin: 0 0 1em 0;
      color: #333;
    }

    .password-box input {
      width: 100%;
      padding: 10px;
      font-size: 1em;
      border: 2px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
      margin-bottom: 0.75em;
    }

    .password-box label {
      display: block;
      text-align: left;
      font-size: 0.85em;
      color: #666;
      margin-bottom: 0.25em;
    }

    .password-box input:focus {
      outline: none;
      border-color: #3377ff;
    }

    .password-box button {
      width: 100%;
      padding: 10px;
      font-size: 1em;
      background: #3377ff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .password-box button:hover:not(:disabled) {
      background: #0055ff;
    }

    .password-box button:disabled {
      background: #999;
      cursor: not-allowed;
    }

    .password-box .error {
      color: #c00;
      font-size: 0.9em;
      margin-top: 0.5em;
    }

    .controls {
      padding-bottom: 1em;
    }

    canvas {
      /* if canvas overflows body */
      margin-right: 1em;
    }

    .color-picker {
      margin: 16px 0;
      display: flex;
      position: relative;
    }

    .color-sample {
      width: 1em;
      border: 1px solid #000;
      margin: 0 0.5em;
    }

    .color-picker {
      margin-left: 5px;
    }

    .palette {
      margin: 1.5em 0 0 10em;
      width: 270px;
      background: #efefef;
      border: 1px solid #bcbcbc;
      border-radius: 1px;
      display: none;
      padding: 1px;
      position: absolute;
      z-index: 1000;
    }

    .palette div {
      width: 18px;
      height: 18px;
      margin: 3px;
      cursor: pointer;
      display: inline-block;
    }

    .palette div:focus {
      outline-width: 2px;
      outline-style: dashed;
    }

    .screen-reader-text {
      border: 0;
      clip: rect(1px, 1px, 1px, 1px);
      -webkit-clip-path: inset(50%);
      clip-path: inset(50%);
      height: 1px;
      margin: -1px;
      overflow: hidden;
      padding: 0;
      position: absolute;
      width: 1px;
      word-wrap: normal !important;
      /* many screen reader and browser combinations announce broken words as they would appear visually */
    }

    noscript p {
      border: 1px solid red;
      padding: 1em;
    }

    #generate {
      border-top: 1px solid #afafaf;
      padding-top: 1em;
    }

    button {
      font-family:
        -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans,
        Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      padding: 5px 1em;
      margin-right: 0.5em;
      font-size: 0.9em;
      background: #3377ff;
      color: #fff;
      border: 0 none;
      cursor: pointer;
      -webkit-border-radius: 3px;
      border-radius: 5px;
    }

    button:hover {
      background: #0055ff;
    }

    /* Asset Picker Styles */
    .asset-picker {
      margin: 0.5em 0;
      position: relative;
    }

    .asset-picker label {
      width: 10em;
      display: inline-block;
    }

    .asset-picker-controls {
      display: inline-flex;
      align-items: center;
      gap: 0.5em;
    }

    .asset-picker input[type="text"] {
      width: 180px;
    }

    .picker-toggle,
    .clear-btn {
      padding: 2px 8px;
      font-size: 0.85em;
      cursor: pointer;
      background: #eee;
      border: 1px solid #ccc;
      border-radius: 3px;
    }

    .picker-toggle:hover,
    .clear-btn:hover {
      background: #ddd;
    }

    .preset-btn {
      padding: 4px 12px;
      font-size: 0.9em;
      cursor: pointer;
      background: #fff;
      border: 1px solid #666;
      border-radius: 3px;
      margin-right: 0.5em;
    }

    .preset-btn:hover {
      background: #e8e8e8;
      border-color: #444;
    }

    .selected-preview {
      display: inline-block;
      width: 32px;
      height: 32px;
      vertical-align: middle;
      border: 1px solid #ccc;
      background: #f9f9f9;
    }

    .selected-preview.has-image {
      border-color: #3377ff;
    }

    .selected-preview img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .asset-grid {
      display: none;
      position: absolute;
      left: 10em;
      top: 100%;
      z-index: 1000;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
      max-width: 400px;
      max-height: 300px;
      overflow-y: auto;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      flex-wrap: wrap;
      gap: 4px;
    }

    .asset-grid.show {
      display: flex;
    }

    .asset-item {
      width: 48px;
      height: 48px;
      border: 2px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      background: #f5f5f5;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .asset-item:hover {
      border-color: #3377ff;
      background: #e8f0ff;
    }

    .asset-item img {
      max-width: 44px;
      max-height: 44px;
      object-fit: contain;
    }

    /* Decoration Drawer Content */
    .decoration-drawer .palette-hint {
      font-size: 0.85em;
      color: #666;
      margin: 0 0 1em 0;
    }

    .palette-category {
      margin-bottom: 1em;
    }

    .palette-category h5 {
      margin: 0 0 0.5em 0;
      font-size: 0.9em;
      color: #555;
    }

    .palette-items {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .palette-item {
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border: 2px solid transparent;
      border-radius: 4px;
      background: #fff;
      transition:
        border-color 0.15s,
        background-color 0.15s;
    }

    .palette-item:hover {
      border-color: #aaa;
      background: #f0f0f0;
    }

    .palette-item.selected {
      border-color: #3377ff;
      background: #e8f0ff;
    }

    .palette-item img {
      max-width: 72px;
      max-height: 72px;
      object-fit: contain;
    }

    /* Custom Decoration Library */
    .decoration-library-section {
      margin-top: 1em;
      padding-top: 1em;
      border-top: 1px solid #ddd;
    }

    .decoration-library-section h5 {
      margin: 0 0 0.5em 0;
      font-size: 0.9em;
      color: #555;
    }

    .upload-zone {
      border: 2px dashed #ccc;
      border-radius: 4px;
      padding: 12px;
      text-align: center;
      margin-bottom: 10px;
      background: #fafafa;
      transition:
        border-color 0.2s,
        background-color 0.2s;
    }

    .upload-zone.drag-over {
      border-color: #3377ff;
      background: #f0f8ff;
    }

    .upload-zone p {
      margin: 0;
      font-size: 0.85em;
      color: #666;
    }

    .upload-zone button {
      background: #3377ff;
      color: white;
      border: none;
      padding: 4px 12px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 0.85em;
    }

    .upload-zone button:hover {
      background: #2266ee;
    }

    .upload-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 8px;
      justify-content: center;
    }

    .upload-controls select {
      padding: 4px 8px;
      font-size: 0.85em;
      border: 1px solid #ccc;
      border-radius: 3px;
    }

    .category-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }

    .category-controls select {
      flex: 1;
      padding: 4px 8px;
      font-size: 0.85em;
      border: 1px solid #ccc;
      border-radius: 3px;
    }

    .category-controls button {
      padding: 5px 10px;
      font-size: 0.8em;
      background: #e3f2fd;
      color: #1565c0;
      border: 1px solid #90caf9;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.15s ease;
    }

    .category-controls button:hover {
      background: #bbdefb;
      border-color: #64b5f6;
    }

    .custom-decoration-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 6px;
      max-height: 180px;
      overflow-y: auto;
      padding: 4px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .custom-decoration-item {
      position: relative;
      aspect-ratio: 1;
      border: 2px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f9f9f9;
      transition:
        border-color 0.15s,
        background-color 0.15s;
    }

    .custom-decoration-item:hover {
      border-color: #3377ff;
      background: #f0f0f0;
    }

    .custom-decoration-item.selected {
      border-color: #3377ff;
      background: #e8f0ff;
    }

    .custom-decoration-item img {
      max-width: 90%;
      max-height: 90%;
      object-fit: contain;
    }

    .custom-decoration-item .delete-btn {
      position: absolute;
      top: -6px;
      right: -6px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #ff5555;
      color: white;
      border: none;
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      display: none;
      padding: 0;
    }

    .custom-decoration-item:hover .delete-btn {
      display: block;
    }

    .custom-decoration-item .delete-btn:hover {
      background: #ff3333;
    }

    .library-empty {
      grid-column: 1 / -1;
      text-align: center;
      color: #999;
      font-size: 0.85em;
      padding: 20px;
    }

    .storage-info {
      font-size: 0.75em;
      color: #888;
      margin-top: 6px;
      text-align: right;
    }

    .storage-info.storage-warning {
      color: #cc6600;
      font-weight: bold;
    }

    /* Auto-placement section */
    .auto-placement-section {
      margin-top: 12px;
      padding: 10px;
      background: #f0f4f8;
      border-radius: 6px;
      border: 1px solid #d0d8e0;
    }

    .auto-placement-section h5 {
      margin: 0 0 8px 0;
      font-size: 0.9em;
      color: #445;
    }

    .auto-placement-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
      font-size: 0.85em;
    }

    .auto-placement-row label {
      min-width: 70px;
      color: #555;
    }

    .auto-placement-row input[type="range"] {
      flex: 1;
    }

    .auto-placement-actions {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    .auto-placement-actions button {
      flex: 1;
      padding: 6px 10px;
      font-size: 0.85em;
      border-radius: 4px;
      cursor: pointer;
    }

    #auto-place-btn {
      background: #4a7c4e;
      color: white;
      border: none;
    }

    #auto-place-btn:hover {
      background: #3d6640;
    }

    #clear-auto-placed-btn {
      background: #f5f5f5;
      border: 1px solid #ccc;
      color: #666;
    }

    #clear-auto-placed-btn:hover {
      background: #eee;
    }

    .auto-placement-hint {
      font-size: 0.75em;
      color: #888;
      margin: 8px 0 0 0;
      line-height: 1.3;
    }

    /* Free-form decoration controls - floating under selected decoration */
    .freeform-controls {
      position: fixed;
      z-index: 1000;
      padding: 8px 12px;
      background: rgba(232, 240, 255, 0.95);
      border: 1px solid #3377ff;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      pointer-events: auto;
      transform: translateX(-50%);
      /* Center horizontally */
    }

    .freeform-controls label {
      font-size: 0.8em;
      margin-right: 4px;
    }

    .freeform-controls input[type="range"] {
      width: 70px;
      vertical-align: middle;
    }

    .freeform-scale-value {
      font-size: 0.8em;
      margin-left: 4px;
      min-width: 35px;
      display: inline-block;
    }

    .freeform-zorder {
      margin-top: 6px;
      display: flex;
      gap: 6px;
      justify-content: center;
    }

    .freeform-controls button {
      padding: 3px 8px;
      font-size: 0.75em;
      background: #fff;
      color: #333;
      border: 1px solid #ccc;
      border-radius: 3px;
      cursor: pointer;
    }

    .freeform-controls button:hover {
      background: #f0f0f0;
    }

    .freeform-controls button.danger {
      background: #ffeeee;
      border-color: #cc6666;
      color: #cc3333;
    }

    .freeform-controls button.danger:hover {
      background: #ffdddd;
    }

    .freeform-controls .clip-toggle {
      width: 28px;
      height: 28px;
      padding: 0;
      font-size: 16px;
      line-height: 1;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .freeform-controls .clip-toggle:hover {
      background: #f0f0f0;
    }

    .freeform-controls .clip-toggle.active {
      background: #3377ff;
      border-color: #2266dd;
      color: #fff;
    }

    .freeform-controls .clip-toggle.adjusting {
      animation: pulse-clip 0.8s ease-in-out infinite;
    }

    .freeform-controls .clip-hint {
      font-size: 0.75em;
      color: #3377ff;
      margin-left: 8px;
      font-style: italic;
    }

    /* Grid decoration controls (simpler than free-form) */
    .grid-decoration-controls {
      position: fixed;
      z-index: 1000;
      padding: 6px 10px;
      background: rgba(232, 240, 255, 0.95);
      border: 1px solid #3377ff;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      pointer-events: auto;
      transform: translateX(-50%);
    }

    .grid-decoration-controls button {
      padding: 4px 12px;
      font-size: 0.8em;
      background: #ffeeee;
      color: #cc3333;
      border: 1px solid #cc6666;
      border-radius: 3px;
      cursor: pointer;
    }

    .grid-decoration-controls button:hover {
      background: #ffdddd;
    }

    /* Hide cursor when in free-form placement mode */
    #maze.freeform-placement-mode {
      cursor: none !important;
    }

    /* Floating preview for free-form decoration placement */
    #freeform-preview {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      opacity: 0.7;
      display: none;
      transform-origin: center bottom;
    }

    #freeform-preview img {
      display: block;
      max-width: none;
    }

    /* Placement scale control (shown during free-form placement mode) */
    .placement-scale-control {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      z-index: 1001;
      display: none;
      align-items: center;
      gap: 10px;
    }

    .placement-scale-control label {
      font-size: 0.9em;
      font-weight: 500;
    }

    .placement-scale-control input[type="range"] {
      width: 150px;
      vertical-align: middle;
    }

    .placement-scale-control .scale-value {
      font-size: 0.85em;
      min-width: 3em;
    }

    .placement-scale-control .hint {
      font-size: 0.75em;
      color: #666;
      margin-left: 10px;
    }

    .palette-actions {
      display: flex;
      gap: 0.5em;
      margin-top: 1em;
      padding-top: 1em;
      border-top: 1px solid #ddd;
    }

    .palette-actions button,
    .palette-export button {
      padding: 6px 12px;
      font-size: 0.85em;
      cursor: pointer;
      background: #fff;
      border: 1px solid #666;
      border-radius: 3px;
      color: #333;
      font-weight: 500;
    }

    .palette-actions button:hover,
    .palette-export button:hover {
      background: #e8e8e8;
      border-color: #444;
    }

    /* Multi-select tile picker */
    .add-blank-btn {
      padding: 2px 8px;
      font-size: 0.85em;
      cursor: pointer;
      background: #e8f0ff;
      border: 1px solid #3377ff;
      border-radius: 3px;
      color: #3377ff;
    }

    .add-blank-btn:hover {
      background: #d0e0ff;
    }

    .selected-tiles {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 0.5em;
      max-height: 150px;
      overflow-y: auto;
      min-height: 0;
    }

    .selected-tiles:empty {
      display: none;
    }

    .tile-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 0.85em;
    }

    .tile-row img {
      width: 32px;
      height: 32px;
      object-fit: contain;
      flex-shrink: 0;
    }

    .tile-row .blank-indicator {
      width: 32px;
      height: 32px;
      background: linear-gradient(45deg,
          #ddd 25%,
          #fff 25%,
          #fff 50%,
          #ddd 50%,
          #ddd 75%,
          #fff 75%);
      background-size: 8px 8px;
      border: 1px solid #ccc;
      flex-shrink: 0;
    }

    .tile-row .weight-label {
      font-size: 0.8em;
      color: #666;
    }

    .tile-row .weight-input {
      width: 50px;
      padding: 2px 4px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 0.9em;
    }

    .tile-row .remove-tile {
      width: 20px;
      height: 20px;
      padding: 0;
      border: none;
      background: #e0e0e0;
      border-radius: 50%;
      cursor: pointer;
      font-size: 12px;
      line-height: 20px;
      text-align: center;
      margin-left: auto;
      flex-shrink: 0;
    }

    .tile-row .remove-tile:hover {
      background: #ff6666;
      color: white;
    }

    /* Legacy chip styles for backwards compatibility */
    .tile-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 4px 2px 2px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 0.85em;
    }

    .tile-chip img {
      width: 24px;
      height: 24px;
      object-fit: contain;
    }

    .tile-chip .blank-indicator {
      width: 24px;
      height: 24px;
      background: linear-gradient(45deg,
          #ddd 25%,
          #fff 25%,
          #fff 50%,
          #ddd 50%,
          #ddd 75%,
          #fff 75%);
      background-size: 8px 8px;
      border: 1px solid #ccc;
    }

    .tile-chip .remove-chip {
      width: 16px;
      height: 16px;
      padding: 0;
      border: none;
      background: #e0e0e0;
      border-radius: 50%;
      cursor: pointer;
      font-size: 10px;
      line-height: 16px;
      text-align: center;
    }

    .tile-chip .remove-chip:hover {
      background: #ff6666;
      color: white;
    }

    .palette-export {
      display: flex;
      gap: 0.5em;
      margin-top: 0.5em;
    }

    .palette-export button {
      padding: 4px 8px;
      font-size: 0.8em;
      cursor: pointer;
      background: #f8f8f8;
      border: 1px solid #ccc;
      border-radius: 3px;
    }

    .palette-export button:hover {
      background: #e8e8e8;
    }

    .hover-info {
      position: fixed;
      top: 10px;
      right: 20px;
      padding: 0.5em 1em;
      font-size: 0.85em;
      background: #e3f2fd;
      border: 1px solid #90caf9;
      border-radius: 4px;
      color: #1565c0;
      z-index: 1003;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      transition: right 0.3s ease;
    }

    body.decorations-open .hover-info {
      right: 360px;
    }

    .hover-info:empty {
      display: none;
    }

    /* Segmented button groups */
    .segmented-buttons {
      display: inline-flex;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid #ccc;
      background: #f5f5f5;
    }

    .segmented-buttons button,
    .segmented-buttons .segment {
      padding: 6px 12px;
      font-size: 0.85em;
      border: none;
      background: transparent;
      color: #555;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
      border-right: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .segmented-buttons button:last-child,
    .segmented-buttons .segment:last-child {
      border-right: none;
    }

    .segmented-buttons button:hover,
    .segmented-buttons .segment:hover {
      background: #e8e8e8;
    }

    .segmented-buttons button.selected,
    .segmented-buttons .segment.selected {
      background: #1976d2;
      color: white;
    }

    #wall-tool-add.selected {
      background: #388e3c;
    }

    #wall-tool-remove.selected {
      background: #d32f2f;
    }

    /* Segment with hidden radio */
    .segmented-buttons .segment input[type="radio"] {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .segmented-buttons .segment input[type="radio"]:checked+span {
      color: white;
    }

    .segmented-buttons .segment:has(input:checked) {
      background: #1976d2;
      color: white;
    }

    /* Wall tools container */
    .wall-tools {
      display: flex;
      align-items: center;
      gap: 0.75em;
      margin-bottom: 1em;
    }

    .wall-tools>label {
      font-weight: 500;
      font-size: 0.9em;
      color: #333;
    }

    /* Layer toggle container */
    .layer-toggle {
      display: flex;
      align-items: center;
      gap: 0.75em;
      margin-bottom: 1em;
    }

    .layer-toggle>label:first-child {
      font-weight: 500;
      font-size: 0.9em;
      color: #333;
    }

    /* Decoration tools */
    .decoration-tools {
      margin-bottom: 1em;
    }

    .tool-btn {
      padding: 0.4em 0.8em;
      border: 1px solid #ccc;
      background: #f5f5f5;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85em;
      color: #333;
      transition: all 0.15s ease;
    }

    .tool-btn:hover {
      background: #e8e8e8;
      border-color: #999;
    }

    .tool-btn.selected {
      background: #ff6b6b;
      color: white;
      border-color: #ff5252;
    }

    /* Toggle switch */
    .switch {
      position: relative;
      width: 44px;
      height: 24px;
      flex-shrink: 0;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .switch .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.2s;
      border-radius: 24px;
    }

    .switch .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.2s;
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    .switch input:checked+.slider {
      background-color: #1976d2;
    }

    .switch input:checked+.slider:before {
      transform: translateX(20px);
    }

    .switch input:focus+.slider {
      box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.3);
    }

    /* Placement mode toggle */
    .placement-mode-toggle {
      display: flex;
      align-items: center;
      margin-bottom: 1em;
    }

    .switch-label {
      display: flex;
      align-items: center;
      gap: 0.75em;
      cursor: pointer;
      font-size: 0.9em;
      font-weight: 500;
      color: #333;
    }

    #undo-decoration:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Main layout structure */
    .main-layout {
      display: flex;
      flex-direction: column;
    }

    .settings-panel {
      position: fixed;
      top: 0;
      left: 0;
      width: 320px;
      height: 100vh;
      background: #fff;
      box-shadow: 2px 0 12px rgba(0, 0, 0, 0.15);
      z-index: 1002;
      overflow-y: auto;
      padding: 1em;
      box-sizing: border-box;
      transform: translateX(0);
      transition: transform 0.3s ease;
    }

    .settings-panel.hidden {
      transform: translateX(-100%);
    }

    .settings-logout {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 1em;
      border-top: 1px solid #ddd;
      background: #f9f9f9;
    }

    .settings-logout button {
      width: 100%;
      padding: 10px;
      font-size: 0.9em;
      background: #666;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .settings-logout button:hover {
      background: #444;
    }

    /* Push main content when drawers are open */
    .maze-area {
      transition:
        margin-left 0.3s ease,
        margin-right 0.3s ease;
    }

    body.drawer-open .maze-area {
      margin-left: calc(320px + 2em);
    }

    body.decorations-open #maze,
    body.decorations-open #maze-preview-overlay {
      margin-right: calc(340px + 2em);
    }

    .settings-panel .controls {
      padding-bottom: 1em;
    }

    /* Settings panel tabs */
    .settings-tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin: -1em -1em 1em -1em;
      padding: 0 1em;
      background: #f5f5f5;
    }

    .settings-tab {
      padding: 0.75em 1.25em;
      border: none;
      background: none;
      cursor: pointer;
      font-size: 0.95em;
      color: #666;
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
      transition:
        color 0.2s,
        border-color 0.2s;
    }

    .settings-tab:hover {
      color: #333;
    }

    .settings-tab.active {
      color: #3377ff;
      border-bottom-color: #3377ff;
      font-weight: 500;
    }

    .settings-tab-content {
      display: none;
    }

    .settings-tab-content.active {
      display: block;
    }

    /* Map browser styles */
    .map-browser {
      padding: 0.5em 0;
    }

    .save-map-section {
      margin-bottom: 1.5em;
      padding-bottom: 1em;
      border-bottom: 1px solid #ddd;
    }

    .save-map-section label {
      display: block;
      margin-bottom: 0.5em;
      font-weight: 500;
    }

    .save-map-row {
      display: flex;
      gap: 0.5em;
    }

    .save-map-row input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .save-map-row button {
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s, opacity 0.2s;
    }

    .save-map-row .save-new-btn {
      position: relative;
      background: #22c55e;
      border: 1px solid #16a34a;
      color: white;
    }

    .save-map-row .save-new-btn:hover:not(:disabled) {
      background: #16a34a;
    }

    .save-map-row .save-new-btn:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    .save-map-row .save-new-btn .plus-icon {
      position: absolute;
      bottom: 2px;
      right: 2px;
      background: #22c55e;
      border-radius: 2px;
    }

    .save-map-row .update-btn {
      background: #3b82f6;
      border: 1px solid #2563eb;
      color: white;
    }

    .save-map-row .update-btn:hover:not(:disabled) {
      background: #2563eb;
    }

    .save-map-row .update-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .save-map-row .update-btn:disabled.saving {
      cursor: wait;
      opacity: 0.6;
    }

    .current-map-info {
      display: none;
    }

    .database-tools {
      display: flex;
      gap: 0.5em;
      flex-wrap: wrap;
    }

    .database-tools button {
      padding: 6px 12px;
      font-size: 0.85em;
      background: #f5f5f5;
      color: #333;
      border: 1px solid #999;
      border-radius: 4px;
      cursor: pointer;
    }

    .database-tools button:hover {
      background: #e8e8e8;
    }

    .apply-changes-row {
      display: flex;
      align-items: center;
      gap: 0.75em;
      padding: 0.5em;
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 4px;
      margin: 0.5em 0;
    }

    .apply-btn {
      padding: 6px 12px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
    }

    .apply-btn:hover {
      background: #43a047;
    }

    .apply-hint {
      font-size: 0.85em;
      color: #856404;
    }

    .saved-maps-list {
      display: flex;
      flex-direction: column;
      gap: 0.75em;
      max-height: calc(100vh - 250px);
      overflow-y: auto;
      padding-top: 10px;
    }

    .saved-map-item {
      position: relative;
      display: flex;
      flex-direction: column;
      padding: 0.5em;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      overflow: visible;
      transition:
        border-color 0.2s,
        background 0.2s;
    }

    .saved-map-item:hover {
      border-color: #3377ff;
      background: #f8faff;
    }

    .saved-map-item.editing {
      border-color: #22c55e;
      background: #f0fdf4;
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.2);
    }

    .saved-map-item.editing::before {
      content: "Editing";
      position: absolute;
      top: -8px;
      left: 8px;
      font-size: 0.65em;
      font-weight: 600;
      text-transform: uppercase;
      color: white;
      background: #22c55e;
      padding: 2px 6px;
      border-radius: 3px;
      z-index: 1;
    }

    .saved-map-content {
      display: flex;
      gap: 0.75em;
    }

    .saved-map-thumbnail {
      width: 80px;
      height: 60px;
      background: #f0f0f0;
      border-radius: 3px;
      overflow: hidden;
      flex-shrink: 0;
    }

    .saved-map-thumbnail img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .saved-map-info {
      flex: 1;
      min-width: 0;
    }

    .saved-map-name {
      font-weight: 500;
      margin-bottom: 0.25em;
    }

    .saved-map-meta {
      font-size: 0.8em;
      color: #666;
    }

    .saved-map-actions {
      display: flex;
      flex-direction: row;
      gap: 0.5em;
      margin-top: 0.5em;
      padding-top: 0.5em;
      border-top: 1px solid #eee;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .saved-map-item:hover .saved-map-actions {
      opacity: 1;
    }

    .saved-map-actions button {
      flex: 1;
      padding: 4px 8px;
      font-size: 0.75em;
      background: #f5f5f5;
      border: 1px solid #999;
      border-radius: 3px;
      cursor: pointer;
      color: #333;
    }

    .saved-map-actions button:hover {
      background: #e8e8e8;
      border-color: #666;
    }

    .saved-map-actions button.delete-btn:hover {
      background: #ffe0e0;
      border-color: #f88;
      color: #c00;
    }

    .no-saved-maps {
      text-align: center;
      color: #888;
      padding: 2em 1em;
      font-style: italic;
    }

    .saved-maps-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5em;
    }

    .saved-maps-header h4 {
      margin: 0;
    }

    .download-all-btn {
      padding: 4px 10px;
      font-size: 0.8em;
      background: #f5f5f5;
      color: #333;
      border: 1px solid #999;
      border-radius: 3px;
      cursor: pointer;
    }

    .download-all-btn:hover {
      background: #e8e8e8;
    }

    .download-all-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Project selector styles */
    .project-selector {
      display: flex;
      align-items: center;
      gap: 0.5em;
      margin-bottom: 0.75em;
    }

    .project-selector label {
      font-weight: 500;
      white-space: nowrap;
    }

    .project-selector select {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .project-selector button {
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #f5f5f5;
      color: #333;
      cursor: pointer;
    }

    .project-selector button:hover {
      background: #e8e8e8;
    }

    /* Project list styles */
    .project-list {
      display: flex;
      flex-direction: column;
      gap: 0.5em;
    }

    .project-item {
      display: flex;
      align-items: center;
      gap: 0.5em;
      padding: 0.5em;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .project-item .project-name {
      flex: 1;
      font-weight: 500;
    }

    .project-item .project-count {
      color: #666;
      font-size: 0.85em;
    }

    .project-item button {
      padding: 4px 8px;
      font-size: 0.75em;
      background: #f5f5f5;
      color: #333;
      border: 1px solid #999;
      border-radius: 3px;
      cursor: pointer;
    }

    .project-item button:hover {
      background: #e8e8e8;
    }

    .project-item button.delete-project-btn:hover {
      background: #ffe0e0;
      border-color: #f88;
      color: #c00;
    }

    .add-project-row {
      display: flex;
      gap: 0.5em;
      margin-bottom: 1em;
    }

    .add-project-row input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    /* Drag and drop styles */
    .saved-map-item {
      cursor: grab;
    }

    .saved-map-item.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .saved-map-item.drag-over {
      border-color: #3377ff;
      border-style: dashed;
      background: #e8f0ff;
    }

    .drag-handle {
      display: flex;
      align-items: center;
      padding: 0 0.5em;
      color: #999;
      cursor: grab;
    }

    .drag-handle:hover {
      color: #666;
    }

    .drag-handle svg {
      width: 16px;
      height: 16px;
    }

    /* FAB - Generate New Maze button */
    .fab-generate {
      position: fixed;
      bottom: 80px;
      right: 1em;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: #4caf50;
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1001;
      display: flex;
      align-items: center;
      justify-content: center;
      transition:
        transform 0.2s ease,
        background 0.2s ease,
        box-shadow 0.2s ease;
    }

    .fab-generate:hover {
      background: #43a047;
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
    }

    .fab-generate:active {
      transform: scale(0.95);
    }

    .fab-generate svg {
      width: 28px;
      height: 28px;
      fill: currentColor;
    }

    .fab-generate .fab-tooltip {
      position: absolute;
      right: 100%;
      margin-right: 10px;
      padding: 6px 12px;
      background: #333;
      color: white;
      font-size: 0.85em;
      border-radius: 4px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }

    .fab-generate:hover .fab-tooltip {
      opacity: 1;
    }

    /* FAB - Download Map button */
    .fab-download {
      position: fixed;
      bottom: 150px;
      right: 1em;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: #2196f3;
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1001;
      display: flex;
      align-items: center;
      justify-content: center;
      transition:
        transform 0.2s ease,
        background 0.2s ease,
        box-shadow 0.2s ease;
    }

    .fab-download:hover {
      background: #1976d2;
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
    }

    .fab-download:active {
      transform: scale(0.95);
    }

    .fab-download svg {
      width: 28px;
      height: 28px;
      fill: currentColor;
    }

    .fab-download .fab-tooltip {
      position: absolute;
      right: 100%;
      margin-right: 10px;
      padding: 6px 12px;
      background: #333;
      color: white;
      font-size: 0.85em;
      border-radius: 4px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }

    .fab-download:hover .fab-tooltip {
      opacity: 1;
    }

    /* FAB - Publish button */
    .fab-publish {
      position: fixed;
      bottom: 220px;
      right: 1em;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: #9c27b0;
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1001;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
    }

    .fab-publish:hover {
      background: #7b1fa2;
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
    }

    .fab-publish:active {
      transform: scale(0.95);
    }

    .fab-publish svg {
      width: 28px;
      height: 28px;
      fill: currentColor;
    }

    .fab-publish .fab-tooltip {
      position: absolute;
      right: 100%;
      margin-right: 10px;
      padding: 6px 12px;
      background: #333;
      color: white;
      font-size: 0.85em;
      border-radius: 4px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }

    .fab-publish:hover .fab-tooltip {
      opacity: 1;
    }

    /* Hide publish FAB when in publishing mode */
    body.publishing-mode .fab-publish {
      display: none;
    }

    /* Publishing Mode Toolbar */
    .publishing-toolbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 12px 20px;
      z-index: 1100;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .publishing-toolbar-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: 1200px;
      margin: 0 auto;
    }

    .publishing-title {
      font-size: 1.1em;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .publishing-title::before {
      content: '';
      display: inline-block;
      width: 8px;
      height: 8px;
      background: #4caf50;
      border-radius: 50%;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.2); }
    }

    .publishing-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .publishing-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 0.9em;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .publishing-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .publishing-btn:active {
      transform: scale(0.97);
    }

    .publishing-btn-primary {
      background: #4caf50;
    }

    .publishing-btn-primary:hover {
      background: #43a047;
    }

    .publishing-btn-secondary {
      background: rgba(255, 255, 255, 0.15);
    }

    .publishing-btn-secondary:hover {
      background: rgba(255, 0, 0, 0.3);
    }

    .publishing-btn-export {
      background: #2196f3;
    }

    .publishing-btn-export:hover {
      background: #1976d2;
    }

    /* Adjust body when in publishing mode */
    body.publishing-mode {
      padding-top: 60px;
    }

    /* Border Library Modal */
    .border-library-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .border-library-modal.hidden {
      display: none;
    }

    .border-library-content {
      background: #fff;
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .border-library-header {
      padding: 16px 20px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .border-library-header h3 {
      margin: 0;
      font-size: 1.2em;
    }

    .border-library-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      padding: 0;
      line-height: 1;
    }

    .border-library-close:hover {
      color: #333;
    }

    .border-library-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }

    .border-upload-zone {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      margin-bottom: 20px;
      background: #f9f9f9;
      transition: all 0.2s;
    }

    .border-upload-zone:hover,
    .border-upload-zone.dragover {
      border-color: #667eea;
      background: #f0f4ff;
    }

    .border-upload-zone p {
      margin: 0;
      color: #666;
    }

    .border-upload-zone button {
      margin-left: 8px;
      padding: 6px 12px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .border-upload-zone button:hover {
      background: #5a6fd6;
    }

    .border-library-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 16px;
    }

    .border-item {
      position: relative;
      border: 2px solid #eee;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s;
      aspect-ratio: 11 / 8.5;
      background: #f5f5f5;
    }

    .border-item:hover {
      border-color: #667eea;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }

    .border-item.selected {
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
    }

    .border-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .border-item-actions {
      position: absolute;
      top: 4px;
      right: 4px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .border-item:hover .border-item-actions {
      opacity: 1;
    }

    .border-item-delete {
      background: rgba(220, 53, 69, 0.9);
      color: white;
      border: none;
      border-radius: 4px;
      width: 24px;
      height: 24px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .border-item-delete:hover {
      background: #dc3545;
    }

    .border-item-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      font-size: 11px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .border-library-empty {
      text-align: center;
      padding: 40px;
      color: #999;
    }

    .border-library-loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    /* Border Assignment UI */
    .border-assignment-section {
      border-top: 1px solid #eee;
      padding-top: 16px;
      margin-top: 16px;
    }

    .border-assignment-section h4 {
      margin: 0 0 12px 0;
      font-size: 0.95em;
      color: #333;
    }

    .assignment-mode-toggle {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }

    .assignment-mode-toggle label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 6px;
      transition: background 0.2s;
    }

    .assignment-mode-toggle label:hover {
      background: #f5f5f5;
    }

    .assignment-mode-toggle input[type="radio"] {
      margin: 0;
    }

    .assignment-mode-toggle .mode-description {
      font-size: 0.85em;
      color: #666;
      margin-left: 20px;
    }

    .border-item.selectable {
      position: relative;
    }

    .border-item-checkbox {
      position: absolute;
      top: 8px;
      left: 8px;
      width: 22px;
      height: 22px;
      background: white;
      border: 2px solid #667eea;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 1;
    }

    .border-item.selectable:hover .border-item-checkbox,
    .border-item.selectable.selected .border-item-checkbox {
      opacity: 1;
    }

    .border-item.selectable.selected .border-item-checkbox {
      background: #667eea;
    }

    .border-item-checkbox svg {
      width: 14px;
      height: 14px;
      fill: white;
      display: none;
    }

    .border-item.selectable.selected .border-item-checkbox svg {
      display: block;
    }

    /* Border Preview Section */
    .border-preview-section {
      border-top: 1px solid #eee;
      padding-top: 16px;
      margin-top: 16px;
    }

    .border-preview-section h4 {
      margin: 0 0 12px 0;
      font-size: 0.95em;
      color: #333;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .border-preview-actions {
      display: flex;
      gap: 8px;
    }

    .border-preview-actions button {
      padding: 4px 10px;
      font-size: 0.8em;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #667eea;
      color: white;
    }

    .border-preview-actions button:hover {
      background: #5a6fd6;
    }

    .border-preview-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 12px;
      max-height: 200px;
      overflow-y: auto;
      padding: 4px;
    }

    .border-preview-item {
      position: relative;
      border: 2px solid #eee;
      border-radius: 6px;
      overflow: hidden;
      aspect-ratio: 11 / 8.5;
      background: #f5f5f5;
    }

    .border-preview-item img.border-img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
    }

    .border-preview-item .map-thumbnail {
      position: absolute;
      top: 10%;
      left: 10%;
      width: 80%;
      height: 80%;
      object-fit: contain;
      z-index: 0;
      background: white;
    }

    .border-preview-item .map-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 4px 6px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 10px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      z-index: 2;
    }

    .border-preview-item .reroll-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3;
    }

    .border-preview-item:hover .reroll-btn {
      opacity: 1;
    }

    .border-preview-item .reroll-btn:hover {
      background: #667eea;
      color: white;
    }

    .border-preview-item .reroll-btn svg {
      width: 14px;
      height: 14px;
    }

    .border-preview-empty {
      text-align: center;
      padding: 20px;
      color: #999;
      font-size: 0.9em;
    }

    .border-library-footer {
      padding: 16px 20px;
      border-top: 1px solid #eee;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .border-library-footer button {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 0.9em;
      cursor: pointer;
      transition: background 0.2s;
    }

    .border-library-footer .btn-cancel {
      background: #e0e0e0;
      color: #333;
    }

    .border-library-footer .btn-cancel:hover {
      background: #d0d0d0;
    }

    .border-library-footer .btn-apply {
      background: #667eea;
      color: white;
    }

    .border-library-footer .btn-apply:hover {
      background: #5a6fd6;
    }

    .border-library-footer .btn-apply:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    /* Border Margin Slider */
    .border-margin-section {
      border-top: 1px solid #eee;
      padding-top: 16px;
      margin-top: 16px;
    }

    .border-margin-section label {
      display: block;
      font-size: 0.95em;
      color: #333;
      margin-bottom: 8px;
    }

    .border-margin-section input[type="range"] {
      width: 100%;
      margin-bottom: 4px;
    }

    .margin-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.8em;
      color: #666;
    }

    /* Export Progress Modal */
    .export-progress-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 3000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .export-progress-overlay.hidden {
      display: none;
    }

    .export-progress-content {
      background: white;
      border-radius: 12px;
      padding: 32px 48px;
      text-align: center;
      max-width: 400px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .export-progress-content h3 {
      margin: 0 0 16px 0;
      color: #333;
    }

    .export-progress-bar {
      width: 100%;
      height: 8px;
      background: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .export-progress-fill {
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .export-progress-text {
      color: #666;
      font-size: 0.9em;
      margin-bottom: 16px;
    }

    .export-progress-cancel {
      padding: 8px 20px;
      background: #e0e0e0;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9em;
    }

    .export-progress-cancel:hover {
      background: #d0d0d0;
    }

    .maze-area {
      position: relative;
      min-height: 100vh;
      width: fit-content;
    }

    /* Drawer notch tabs */
    .drawer-notch {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      background: #3377ff;
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
      z-index: 1003;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px 8px;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.5px;
      transition: background 0.2s ease;
    }

    .drawer-notch:hover {
      background: #2266dd;
    }

    .drawer-notch.active {
      background: #1a5acc;
    }

    .drawer-notch span {
      writing-mode: vertical-rl;
      text-orientation: mixed;
    }

    /* Left notch (Settings) */
    .drawer-notch.left {
      left: 0;
      border-radius: 0 8px 8px 0;
      transition:
        left 0.3s ease,
        background 0.2s ease;
    }

    .drawer-notch.left.active {
      left: 320px;
    }

    .drawer-notch.left span {
      transform: rotate(180deg);
    }

    /* Right notch (Decorations) */
    .drawer-notch.right {
      right: -7px;
      border-radius: 8px 0 0 8px;
      transition:
        right 0.3s ease,
        background 0.2s ease;
    }

    .drawer-notch.right.active {
      right: calc(340px - 7px);
    }

    /* Right-side decoration drawer */
    .decoration-drawer {
      position: fixed;
      top: 0;
      right: 0;
      width: 340px;
      height: 100vh;
      background: #fff;
      box-shadow: -2px 0 12px rgba(0, 0, 0, 0.15);
      z-index: 1002;
      overflow-y: auto;
      padding: 1em;
      box-sizing: border-box;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }

    .decoration-drawer.open {
      transform: translateX(0);
    }

    .decoration-drawer h4 {
      margin: 0 0 1em 0;
      padding-bottom: 0.5em;
      border-bottom: 1px solid #ddd;
    }

    /* Hide old palette header in drawer mode */
    .decoration-drawer .palette-header {
      display: none;
    }

    .decoration-drawer .palette-content {
      display: block !important;
    }

    /* Adjust canvas container for sticky panel */
    #maze {
      display: block;
    }

    .canvas-container {
      position: relative;
      display: inline-block;
    }

    /* Toast notifications */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    .toast {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      font-size: 14px;
      max-width: 350px;
      pointer-events: auto;
      animation: toast-in 0.3s ease-out;
    }

    .toast.toast-out {
      animation: toast-out 0.3s ease-in forwards;
    }

    .toast-success {
      background: #f0fdf4;
      border: 1px solid #22c55e;
      color: #166534;
    }

    .toast-error {
      background: #fef2f2;
      border: 1px solid #ef4444;
      color: #991b1b;
    }

    .toast-info {
      background: #eff6ff;
      border: 1px solid #3b82f6;
      color: #1e40af;
    }

    .toast-icon {
      flex-shrink: 0;
      width: 20px;
      height: 20px;
    }

    .toast-message {
      flex: 1;
    }

    .toast-close {
      flex-shrink: 0;
      background: none;
      border: none;
      cursor: pointer;
      padding: 2px;
      opacity: 0.6;
      font-size: 18px;
      line-height: 1;
    }

    .toast-close:hover {
      opacity: 1;
    }

    @keyframes toast-in {
      from {
        opacity: 0;
        transform: translateX(100%);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes toast-out {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(100%);
      }
    }
  </style>
</head>

<body>
  <!-- Login Overlay -->
  <div class="password-overlay" id="login-overlay">
    <div class="password-box">
      <h2>Sign In</h2>
      <div>
        <label for="login-email">Email</label>
        <input type="email" id="login-email" placeholder="email@example.com" autocomplete="email" />
      </div>
      <div>
        <label for="login-password">Password</label>
        <input type="password" id="login-password" placeholder="Password" autocomplete="current-password" />
      </div>
      <button type="button" id="login-submit">Sign In</button>
      <div class="error" id="login-error"></div>
    </div>
  </div>
  <script>
    // Auth initialization - runs early to check session
    (async function() {
      var overlay = document.getElementById("login-overlay");
      var emailInput = document.getElementById("login-email");
      var passwordInput = document.getElementById("login-password");
      var submitBtn = document.getElementById("login-submit");
      var errorDiv = document.getElementById("login-error");

      // Wait for Supabase to be available
      function waitForSupabase() {
        return new Promise(function(resolve) {
          if (typeof SupabaseClient !== "undefined") {
            resolve();
          } else {
            // Check every 50ms for up to 5 seconds
            var attempts = 0;
            var interval = setInterval(function() {
              attempts++;
              if (typeof SupabaseClient !== "undefined") {
                clearInterval(interval);
                resolve();
              } else if (attempts > 100) {
                clearInterval(interval);
                resolve(); // Give up, let it fail gracefully
              }
            }, 50);
          }
        });
      }

      await waitForSupabase();

      // Initialize Supabase if not already done
      if (typeof SupabaseClient !== "undefined" && SupabaseClient.init) {
        SupabaseClient.init();
      }

      // Check for existing session
      async function checkSession() {
        if (typeof SupabaseClient === "undefined") {
          console.error("Supabase not available");
          return false;
        }

        var result = await SupabaseClient.getSession();
        return result.data && result.data.session !== null;
      }

      // Handle login
      async function handleLogin() {
        var email = emailInput.value.trim();
        var password = passwordInput.value;

        if (!email || !password) {
          errorDiv.textContent = "Please enter email and password";
          return;
        }

        submitBtn.disabled = true;
        submitBtn.textContent = "Signing in...";
        errorDiv.textContent = "";

        try {
          var result = await SupabaseClient.signIn(email, password);

          if (result.error) {
            errorDiv.textContent = result.error.message || "Login failed";
            submitBtn.disabled = false;
            submitBtn.textContent = "Sign In";
            return;
          }

          // Success - hide overlay
          overlay.classList.add("hidden");
        } catch (err) {
          errorDiv.textContent = "An error occurred. Please try again.";
          console.error("Login error:", err);
          submitBtn.disabled = false;
          submitBtn.textContent = "Sign In";
        }
      }

      // Check if already logged in
      var isLoggedIn = await checkSession();
      if (isLoggedIn) {
        overlay.classList.add("hidden");
      } else {
        // Focus email input
        emailInput.focus();
      }

      // Event listeners
      submitBtn.addEventListener("click", handleLogin);

      emailInput.addEventListener("keypress", function(e) {
        if (e.key === "Enter") {
          passwordInput.focus();
        }
      });

      passwordInput.addEventListener("keypress", function(e) {
        if (e.key === "Enter") {
          handleLogin();
        }
      });

      // Listen for auth state changes
      if (typeof SupabaseClient !== "undefined") {
        SupabaseClient.onAuthStateChange(function(event, session) {
          if (event === "SIGNED_IN" && session) {
            overlay.classList.add("hidden");
          } else if (event === "SIGNED_OUT") {
            overlay.classList.remove("hidden");
            emailInput.value = "";
            passwordInput.value = "";
            errorDiv.textContent = "";
            submitBtn.disabled = false;
            submitBtn.textContent = "Sign In";
            emailInput.focus();
          }
        });
      }
    })();
  </script>

  <!-- Settings Drawer Notch -->
  <button type="button" class="drawer-notch left" id="settings-toggle" title="Toggle Settings">
    <span>Settings</span>
  </button>

  <div class="settings-panel hidden" id="settings-panel">
    <div class="settings-tabs">
      <button type="button" class="settings-tab active" data-tab="maps">
        Maps
      </button>
      <button type="button" class="settings-tab" data-tab="projects">
        Projects
      </button>
      <button type="button" class="settings-tab" data-tab="settings">
        Settings
      </button>
    </div>

    <div class="settings-tab-content" data-tab-content="settings">
      <div class="controls">
        <p>
          <label for="wall-size">Wall thickness:</label>
          <input id="wall-size" type="number" name="" value="10" min="1" />
        </p>

        <p>
          <label for="display-scale">Display scale:</label>
          <input id="display-scale" type="number" name="" value="5" min="0.25" step="0.25" />
        </p>

        <p>
          <label for="iso-ratio">Isometric angle:</label>
          <select id="iso-ratio" name="iso-ratio">
            <option value="0.5" selected>2:1 Pixel art (~27)</option>
            <option value="0.577">True isometric (~30)</option>
            <option value="0.25">Flat (4:1, ~14)</option>
            <option value="0.75">Steep (4:3, ~37)</option>
            <option value="1.0">Square (1:1, 45)</option>
          </select>
        </p>

        <p>
          <label for="path-width">Path width:</label>
          <input id="path-width" type="number" name="" value="3" min="1" max="5" step="1" />
        </p>

        <p>
          <label for="path-height">Path height:</label>
          <input id="path-height" type="number" name="" value="3" min="1" max="5" step="1" />
        </p>

        <p>
          <label for="width">Columns:</label>
          <input id="width" type="number" name="width" value="10" min="3" max="200" />
        </p>

        <p>
          <label for="height">Rows:</label>
          <input id="height" type="number" name="height" value="10" min="3" max="200" />
        </p>
        <p class="apply-changes-row" id="apply-changes-row" style="display: none">
          <button type="button" id="apply-maze-changes" class="apply-btn">
            Apply Changes
          </button>
          <span class="apply-hint">Maze structure changed - regeneration required</span>
        </p>
        <p>
          <label for="entry">Maze entries:</label>
          <select id="entry" name="entry">
            <option value="">none</option>
            <option value="diagonal">diagonal (NW-SE)</option>
            <option value="diagonal-alt">diagonal (NE-SW)</option>
            <option value="diagonal-random" selected="selected">
              random
            </option>
            <option value="horizontal">exit on left</option>
            <option value="vertical">exit on bottom</option>
            <option value="same-left">both on left side</option>
            <option value="same-right">both on right side</option>
          </select>
        </p>
        <p>
          <label for="flip-start">Flip start position:</label>
          <input id="flip-start" type="checkbox" name="flip-start" />
          <span style="font-size: smaller; color: #666">(move to other end of wall)</span>
        </p>
        <p>
          <label for="flip-exit">Flip exit position:</label>
          <input id="flip-exit" type="checkbox" name="flip-exit" />
          <span style="font-size: smaller; color: #666">(move to other end of wall)</span>
        </p>
        <p>
          <label for="show-entry-indicators">Show entry indicators:</label>
          <input id="show-entry-indicators" type="checkbox" name="show-entry-indicators" checked />
        </p>
        <p>
          <label for="entry-indicator-font-size">Indicator font size:</label>
          <input id="entry-indicator-font-size" type="number" name="entry-indicator-font-size" value="8" min="1"
            max="100" step="1" />
        </p>
        <p>
          <label for="bias">Bias:</label>
          <select id="bias" name="bias">
            <option value="">none</option>
            <option value="horizontal">horizontal</option>
            <option value="vertical">vertical</option>
          </select>
        </p>
        <p>
          <label for="remove_walls">Remove maze walls:</label>
          <input id="remove_walls" type="number" name="remove_walls" value="0" min="0" max="200" />
        </p>
        <p class="desc">
          Click the colors below to select a color from a color pallete.
        </p>
        <div class="color-picker" data-default="#ffffff">
          <label for="backgroundColor">Background Color</label>
          <input type="text" class="" id="backgroundColor" name="backgroundColor" value="#ffffff" />
          <div class="color-sample" style="background-color: #ffffff"></div>
        </div>
        <div class="color-picker" data-default="#000000">
          <label for="color">Maze Color</label>
          <input type="text" class="" id="color" name="color" value="#000000" />
          <div class="color-sample" style="background-color: #000000"></div>
        </div>
        <div class="color-picker" data-default="#cc3737">
          <label for="solveColor">Solve Color</label>
          <input type="text" class="" id="solveColor" name="solveColor" value="#cc3737"
            pattern="^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$" />
          <div class="color-sample" style="background-color: #cc3737"></div>
        </div>
        <p>
          <label for="export-format">Export format:</label>
          <select id="export-format" name="export-format">
            <option value="png" selected="selected">PNG</option>
            <option value="svg">SVG</option>
          </select>
        </p>
        <p class="desc">
          Custom tileset (optional). Select from local assets or enter a URL.
          Leave empty to use default programmatic rendering.
        </p>
        <p>
          <label for="wall-height">Wall height:</label>
          <input id="wall-height" type="number" name="wall-height" value="1.5" min="0.5" max="3" step="0.25" />
        </p>
        <p>
          <label for="show-stroke">Show strokes:</label>
          <input id="show-stroke" type="checkbox" name="show-stroke" checked />
        </p>
        <p>
          <label for="stroke-top">Stroke top:</label>
          <input id="stroke-top" type="checkbox" name="stroke-top" checked />
        </p>
        <p>
          <label for="stroke-bottom">Stroke bottom:</label>
          <input id="stroke-bottom" type="checkbox" name="stroke-bottom" checked />
        </p>
        <p>
          <label for="stroke-corners">Stroke corners:</label>
          <input id="stroke-corners" type="checkbox" name="stroke-corners" />
        </p>
        <p>
          <label for="stroke-wall-corners">Wall corners only:</label>
          <input id="stroke-wall-corners" type="checkbox" name="stroke-wall-corners" checked />
        </p>
        <p>
          <label for="stroke-width">Stroke width:</label>
          <input id="stroke-width" type="number" name="stroke-width" value="1" min="0" max="5" step="0.5" />
        </p>
        <p>
          <label for="debug-stroke-colors">Debug stroke colors:</label>
          <input id="debug-stroke-colors" type="checkbox" name="debug-stroke-colors" />
        </p>
        <p>
          <label for="debug-test-pattern">Debug test pattern:</label>
          <input id="debug-test-pattern" type="checkbox" name="debug-test-pattern" />
          <span style="font-size: smaller; color: #666">(Shows numbered wall configurations)</span>
        </p>
        <p>
          <label for="show-block-numbers">Show block numbers:</label>
          <input id="show-block-numbers" type="checkbox" name="show-block-numbers" />
          <span style="font-size: smaller; color: #666">(Grid coords on walls &amp; pathways)</span>
        </p>
        <p>
          <label for="tight-spacing">Tight spacing:</label>
          <input id="tight-spacing" type="checkbox" name="tight-spacing" />
          <span style="font-size: smaller; color: #666">(Seamless floor tiles for tilesets)</span>
        </p>
        <div class="color-picker" data-default="">
          <label for="wall-bg-color">Wall bg color:</label>
          <input type="text" id="wall-bg-color" name="wall-bg-color" value="#FFFFFF"
            placeholder="Optional, e.g. #8B4513" />
          <div class="color-sample" style="background-color: transparent"></div>
        </div>
        <div class="asset-picker" data-multi="true">
          <label for="tile-wall-left">Wall left face:</label>
          <div class="asset-picker-controls">
            <input id="tile-wall-left" type="text" name="tile-wall-left" value="src/assets/isobrickswall-left.png|1"
              placeholder="URL or select multiple..." />
            <button type="button" class="picker-toggle">Browse</button>
            <button type="button" class="add-blank-btn">+ Blank</button>
            <button type="button" class="clear-btn">Clear All</button>
          </div>
          <div class="selected-tiles"></div>
          <div class="asset-grid"></div>
        </div>
        <div class="asset-picker" data-multi="true">
          <label for="tile-wall-right">Wall right face:</label>
          <div class="asset-picker-controls">
            <input id="tile-wall-right" type="text" name="tile-wall-right" value="src/assets/isobrickswall-right.png|1"
              placeholder="URL or select multiple..." />
            <button type="button" class="picker-toggle">Browse</button>
            <button type="button" class="add-blank-btn">+ Blank</button>
            <button type="button" class="clear-btn">Clear All</button>
          </div>
          <div class="selected-tiles"></div>
          <div class="asset-grid"></div>
        </div>
        <div class="asset-picker" data-multi="true">
          <label for="tile-pathway">Pathway tiles:</label>
          <div class="asset-picker-controls">
            <input id="tile-pathway" type="text" name="tile-pathway" value="" placeholder="URL or select multiple..." />
            <button type="button" class="picker-toggle">Browse</button>
            <button type="button" class="add-blank-btn">+ Blank</button>
            <button type="button" class="clear-btn">Clear All</button>
          </div>
          <div class="selected-tiles"></div>
          <div class="asset-grid"></div>
        </div>
        <p class="desc" style="margin-top: 1em">
          Start/End markers (directional). Use N/S/E/W variants based on gate
          direction.
        </p>
        <p>
          <label>End marker preset:</label>
          <button type="button" id="preset-stairs" class="preset-btn">
            Stairs
          </button>
          <button type="button" id="preset-door" class="preset-btn">
            Door
          </button>
        </p>
        <p>
          <label for="end-marker-offset">End marker Y offset:</label>
          <input id="end-marker-offset" type="number" name="end-marker-offset" value="-3.5" min="-20" max="20"
            step=".25" />
          <span style="font-size: smaller; color: #666">(Vertical, positive = down)</span>
        </p>
        <p>
          <label for="end-marker-offset-x">End marker X offset:</label>
          <input id="end-marker-offset-x" type="number" name="end-marker-offset-x" value="-1" min="-20" max="20"
            step=".25" />
          <span style="font-size: smaller; color: #666">(Horizontal, positive = right)</span>
        </p>
        <div class="asset-picker">
          <label for="tile-start-n">Start (North):</label>
          <div class="asset-picker-controls">
            <input id="tile-start-n" type="text" name="tile-start-n" value="src/assets/isostair.png"
              placeholder="URL or select..." />
            <button type="button" class="picker-toggle">Browse</button>
            <button type="button" class="clear-btn">Clear</button>
            <div class="selected-preview"></div>
          </div>
          <div class="asset-grid"></div>
        </div>
        <div class="asset-picker">
          <label for="tile-start-s">Start (South):</label>
          <div class="asset-picker-controls">
            <input id="tile-start-s" type="text" name="tile-start-s" value="src/assets/isostair.png"
              placeholder="URL or select..." />
            <button type="button" class="picker-toggle">Browse</button>
            <button type="button" class="clear-btn">Clear</button>
            <div class="selected-preview"></div>
          </div>
          <div class="asset-grid"></div>
        </div>
        <div class="asset-picker">
          <label for="tile-start-e">Start (East):</label>
          <div class="asset-picker-controls">
            <input id="tile-start-e" type="text" name="tile-start-e" value="src/assets/isostair2.png"
              placeholder="URL or select..." />
            <button type="button" class="picker-toggle">Browse</button>
            <button type="button" class="clear-btn">Clear</button>
            <div class="selected-preview"></div>
          </div>
          <div class="asset-grid"></div>
        </div>
        <div class="asset-picker">
          <label for="tile-start-w">Start (West):</label>
          <div class="asset-picker-controls">
            <input id="tile-start-w" type="text" name="tile-start-w" value="src/assets/isostair2.png"
              placeholder="URL or select..." />
            <button type="button" class="picker-toggle">Browse</button>
            <button type="button" class="clear-btn">Clear</button>
            <div class="selected-preview"></div>
          </div>
          <div class="asset-grid"></div>
        </div>
        <div class="asset-picker">
          <label for="tile-end-n">End (North):</label>
          <div class="asset-picker-controls">
            <input id="tile-end-n" type="text" name="tile-end-n" value="src/assets/isostair.png"
              placeholder="URL or select..." />
            <button type="button" class="picker-toggle">Browse</button>
            <button type="button" class="clear-btn">Clear</button>
            <div class="selected-preview"></div>
          </div>
          <div class="asset-grid"></div>
        </div>
        <div class="asset-picker">
          <label for="tile-end-s">End (South):</label>
          <div class="asset-picker-controls">
            <input id="tile-end-s" type="text" name="tile-end-s" value="src/assets/isostair.png"
              placeholder="URL or select..." />
            <button type="button" class="picker-toggle">Browse</button>
            <button type="button" class="clear-btn">Clear</button>
            <div class="selected-preview"></div>
          </div>
          <div class="asset-grid"></div>
        </div>
        <div class="asset-picker">
          <label for="tile-end-e">End (East):</label>
          <div class="asset-picker-controls">
            <input id="tile-end-e" type="text" name="tile-end-e" value="src/assets/isostair2.png"
              placeholder="URL or select..." />
            <button type="button" class="picker-toggle">Browse</button>
            <button type="button" class="clear-btn">Clear</button>
            <div class="selected-preview"></div>
          </div>
          <div class="asset-grid"></div>
        </div>
        <div class="asset-picker">
          <label for="tile-end-w">End (West):</label>
          <div class="asset-picker-controls">
            <input id="tile-end-w" type="text" name="tile-end-w" value="src/assets/isostair2.png"
              placeholder="URL or select..." />
            <button type="button" class="picker-toggle">Browse</button>
            <button type="button" class="clear-btn">Clear</button>
            <div class="selected-preview"></div>
          </div>
          <div class="asset-grid"></div>
        </div>
        <div id="generate">
          <button id="create-maze" onclick="initMaze();" class="hide">
            Generate Maze
          </button>
          <a href="" class="hide" id="download">Download Maze</a>
        </div>
        <p class="desc" style="margin-top: 2em">
          Backup &amp; Restore all saved maps and projects.
        </p>
        <div class="database-tools">
          <button type="button" id="export-database-btn">
            Export Database
          </button>
          <button type="button" id="import-database-btn">
            Import Database
          </button>
          <input type="file" id="import-database-file" accept=".json" style="display: none" />
        </div>
      </div>
    </div>
    <!-- End settings tab content -->

    <div class="settings-tab-content active" data-tab-content="maps">
      <div class="map-browser">
        <div class="project-selector">
          <label for="current-project">Project:</label>
          <select id="current-project"></select>
          <button type="button" id="new-project-btn" title="New Project">
            +
          </button>
        </div>
        <div class="save-map-section">
          <label for="save-map-name">Save Current Map</label>
          <div class="save-map-row">
            <input type="text" id="save-map-name" placeholder="Floor 1" />
            <button type="button" id="save-map-btn" class="save-new-btn" title="Save as new map">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                <polyline points="7 3 7 8 15 8"></polyline>
              </svg>
              <svg class="plus-icon" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
            </button>
            <button type="button" id="update-map-btn" class="update-btn" title="Update current map" disabled>
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                <polyline points="7 3 7 8 15 8"></polyline>
              </svg>
            </button>
          </div>
        </div>
        <div class="saved-maps-header">
          <h4>Maps</h4>
          <button type="button" id="download-all-btn" class="download-all-btn">
            Download All
          </button>
        </div>
        <div class="saved-maps-list" id="saved-maps-list">
          <div class="no-saved-maps">No saved maps yet</div>
        </div>
      </div>
    </div>
    <!-- End maps tab content -->

    <div class="settings-tab-content" data-tab-content="projects">
      <div class="map-browser">
        <div class="add-project-row">
          <input type="text" id="new-project-name" placeholder="New project name..." />
          <button type="button" id="add-project-btn">Add</button>
        </div>
        <div class="project-list" id="project-list"></div>
      </div>
    </div>
    <!-- End projects tab content -->

    <!-- Logout Button -->
    <div class="settings-logout">
      <button type="button" id="logout-btn">Sign Out</button>
    </div>
  </div>
  <!-- End settings-panel -->

  <div class="maze-area" id="maze-area">
    <noscript>
      <p>
        Sorry... this site requires JavaScript to generate a maze. Please
        enable it in your browser
      </p>
    </noscript>
    <script type="text/javascript">
      const createMazeButton = document.getElementById("create-maze");
      createMazeButton.classList.toggle("hide");
    </script>
    <canvas id="maze"></canvas>
  </div>
  <!-- End maze-area -->

  <!-- Decorations Drawer Notch -->
  <button type="button" class="drawer-notch right" id="decorations-toggle" title="Toggle Decorations">
    <span>Decorations</span>
  </button>

  <!-- Decorations Drawer -->
  <div class="hover-info" id="hover-info"></div>

  <div class="decoration-drawer" id="decoration-drawer">
    <h4>Decorations</h4>
    <div class="palette-content">
      <p class="palette-hint">
        Select a decoration, then click on a floor tile to place it
      </p>
      <div class="wall-tools">
        <label>Wall Tools:</label>
        <div class="segmented-buttons">
          <button type="button" id="wall-tool-add" class="wall-tool-btn">
            Add
          </button>
          <button type="button" id="wall-tool-remove" class="wall-tool-btn">
            Remove
          </button>
          <button type="button" id="floor-tool-clear" class="wall-tool-btn">
            Clear Floor
          </button>
        </div>
      </div>
      <div class="layer-toggle">
        <label>Layer:</label>
        <div class="segmented-buttons">
          <label class="segment">
            <input type="radio" name="decoration-layer" id="layer-floor" value="floor" checked />
            <span>Floor</span>
          </label>
          <label class="segment">
            <input type="radio" name="decoration-layer" id="layer-overlay" value="overlay" />
            <span>Overlay</span>
          </label>
        </div>
      </div>
      <div class="placement-mode-toggle">
        <label class="switch-label">
          <span>Free placement</span>
          <div class="switch">
            <input type="checkbox" id="free-placement-toggle" />
            <span class="slider"></span>
          </div>
        </label>
      </div>
      <div class="decoration-tools">
        <button type="button" id="decoration-eraser" class="tool-btn" title="Erase decorations">Erase</button>
      </div>
      <div class="palette-category" data-category="furniture">
        <h5>Furniture</h5>
        <div class="palette-items"></div>
      </div>
      <div class="palette-category" data-category="lighting">
        <h5>Lighting</h5>
        <div class="palette-items"></div>
      </div>
      <div class="palette-category" data-category="hazards">
        <h5>Hazards</h5>
        <div class="palette-items"></div>
      </div>
      <div class="palette-category" data-category="walls">
        <h5>Walls</h5>
        <div class="palette-items"></div>
      </div>

      <!-- Custom Decoration Library -->
      <div class="decoration-library-section">
        <h5>Custom Decorations</h5>

        <!-- Upload area -->
        <div class="upload-zone" id="decoration-upload-zone">
          <input type="file" id="decoration-file-input" accept="image/png,image/svg+xml,image/jpeg,image/gif,image/webp"
            multiple hidden />
          <p>
            Drop images here or
            <button type="button" id="browse-decorations-btn">Browse</button>
          </p>
          <div class="upload-controls">
            <label>Category:</label>
            <select id="decoration-upload-category">
              <option value="monsters">Monsters</option>
              <option value="props" selected>Props</option>
              <option value="npcs">NPCs</option>
              <option value="effects">Effects</option>
            </select>
          </div>
        </div>

        <!-- Category filter -->
        <div class="category-controls">
          <select id="decoration-category-filter">
            <option value="all">All Categories</option>
          </select>
          <button type="button" id="add-category-btn">+ Category</button>
        </div>

        <!-- Library grid -->
        <div class="custom-decoration-grid" id="custom-decoration-grid"></div>

        <!-- Auto-placement controls -->
        <div class="auto-placement-section">
          <h5>Auto-Place Decorations</h5>
          <div class="auto-placement-controls">
            <div class="auto-placement-row">
              <label>Density:</label>
              <input type="range" id="auto-placement-density" min="1" max="50" value="10" />
              <span id="auto-placement-density-value">10</span>
            </div>
            <div class="auto-placement-row">
              <label>Seed:</label>
              <input type="number" id="auto-placement-seed" value="" placeholder="Random" style="width: 80px" />
            </div>
            <div class="auto-placement-row">
              <label>Scale range:</label>
              <input type="number" id="auto-placement-scale-min" value="0.5" step="0.1" min="0.1" max="3" style="width: 50px" />
              <span>-</span>
              <input type="number" id="auto-placement-scale-max" value="1.5" step="0.1" min="0.1" max="3" style="width: 50px" />
            </div>
            <div class="auto-placement-actions">
              <button type="button" id="auto-place-btn">Auto-Place Selected</button>
              <button type="button" id="clear-auto-placed-btn">Clear Auto-Placed</button>
            </div>
            <p class="auto-placement-hint">Select decorations above, then click Auto-Place to randomly distribute them on floor tiles.</p>
          </div>
        </div>

        <!-- Storage indicator -->
        <div class="storage-info">
          <span id="storage-used">0 B</span> / ~5 MB used
        </div>
      </div>

      <div class="palette-actions">
        <button type="button" id="undo-decoration" disabled>Undo</button>
        <button type="button" id="deselect-tool">Deselect Tool</button>
        <button type="button" id="clear-decorations">Clear All</button>
      </div>
      <div class="palette-export">
        <button type="button" id="export-decorations">Export Maze</button>
        <button type="button" id="import-decorations">Import Maze</button>
      </div>
    </div>
    <!-- End palette-content -->
  </div>
  <!-- End decoration-drawer -->

  <!-- FAB - Download Map -->
  <button type="button" class="fab-download" id="fab-download" title="Download Map">
    <span class="fab-tooltip">Download</span>
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" />
    </svg>
  </button>

  <!-- FAB - Generate New Maze -->
  <button type="button" class="fab-generate" id="fab-generate" title="Generate New Maze">
    <span class="fab-tooltip">New Maze</span>
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
    </svg>
  </button>

  <!-- FAB - Enter Publishing Mode -->
  <button type="button" class="fab-publish" id="fab-publish" title="Enter Publishing Mode">
    <span class="fab-tooltip">Publish</span>
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path d="M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z"/>
    </svg>
  </button>

  <!-- Publishing Mode Toolbar (hidden by default) -->
  <div class="publishing-toolbar" id="publishing-toolbar" style="display: none;">
    <div class="publishing-toolbar-content">
      <span class="publishing-title">Publishing Mode</span>
      <div class="publishing-controls">
        <button type="button" id="publishing-accept" class="publishing-btn publishing-btn-primary">
          <svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
          Accept
        </button>
        <button type="button" id="publishing-cancel" class="publishing-btn publishing-btn-secondary">
          <svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
          Cancel
        </button>
        <button type="button" id="publishing-borders" class="publishing-btn">
          <svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"/></svg>
          Borders
        </button>
        <button type="button" id="publishing-export" class="publishing-btn publishing-btn-export">
          <svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
          Export PNG
        </button>
      </div>
    </div>
  </div>

  <!-- Border Library Modal -->
  <div class="border-library-modal hidden" id="border-library-modal">
    <div class="border-library-content">
      <div class="border-library-header">
        <h3>Border Library</h3>
        <button type="button" class="border-library-close" id="border-library-close">&times;</button>
      </div>
      <div class="border-library-body">
        <div class="border-upload-zone" id="border-upload-zone">
          <input type="file" id="border-file-input" accept="image/png,image/jpeg" multiple hidden />
          <p>
            Drop border images here (11x8.5" landscape at 300 DPI) or
            <button type="button" id="browse-borders-btn">Browse</button>
          </p>
        </div>
        <div class="border-library-grid" id="border-library-grid">
          <div class="border-library-loading">Loading borders...</div>
        </div>

        <!-- Assignment Mode Section -->
        <div class="border-assignment-section" id="border-assignment-section">
          <h4>Assignment Mode</h4>
          <div class="assignment-mode-toggle">
            <label>
              <input type="radio" name="assignment-mode" value="random" checked />
              <span>Randomly assign from selected borders</span>
            </label>
            <label>
              <input type="radio" name="assignment-mode" value="single" />
              <span>Use single border for all maps</span>
            </label>
            <div class="mode-description" id="single-mode-hint" style="display: none;">
              <em>Select one border above</em>
            </div>
          </div>
        </div>

        <!-- Margin Slider -->
        <div class="border-margin-section">
          <label for="border-margin-slider">Maze Margin: <span id="border-margin-value">1/2"</span></label>
          <input type="range" id="border-margin-slider" min="0" max="16" step="1" value="8" />
          <div class="margin-labels"><span>0"</span><span>1"</span></div>
        </div>

        <!-- Preview Section -->
        <div class="border-preview-section" id="border-preview-section">
          <h4>
            <span>Map Assignments</span>
            <div class="border-preview-actions">
              <button type="button" id="preview-reroll-all">Re-roll All</button>
            </div>
          </h4>
          <div class="border-preview-grid" id="border-preview-grid">
            <div class="border-preview-empty">Select borders and maps will appear here</div>
          </div>
        </div>
      </div>
      <div class="border-library-footer">
        <button type="button" class="btn-cancel" id="border-cancel-btn">Cancel</button>
        <button type="button" class="btn-apply" id="border-apply-btn" disabled>Apply Borders</button>
      </div>
    </div>
  </div>

  <!-- Export Progress Modal -->
  <div class="export-progress-overlay hidden" id="export-progress-overlay">
    <div class="export-progress-content">
      <h3>Exporting Maps</h3>
      <div class="export-progress-bar">
        <div class="export-progress-fill" id="export-progress-fill"></div>
      </div>
      <div class="export-progress-text" id="export-progress-text">Preparing...</div>
      <button type="button" class="export-progress-cancel" id="export-progress-cancel">Cancel</button>
    </div>
  </div>

  <!-- Floating free-form decoration controls (positioned under selected decoration) -->
  <div class="freeform-controls" id="freeform-controls" style="display: none">
    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap">
      <span>
        <label>Scale:</label>
        <input type="range" id="freeform-scale" min="0.01" max="3" step="0.01" value="1" />
        <span class="freeform-scale-value" id="freeform-scale-value">1.0x</span>
      </span>
      <span style="display: flex; align-items: center; gap: 4px">
        <label>Clip:</label>
        <button type="button" id="freeform-clip-left" class="clip-toggle" title="Clip bottom-left (SW)">
          &#9699;
        </button>
        <button type="button" id="freeform-clip-right" class="clip-toggle" title="Clip bottom-right (SE)">
          &#9698;
        </button>
        <span id="clip-adjust-hint" class="clip-hint" style="display: none">Move to adjust, click to confirm</span>
      </span>
    </div>
    <div class="freeform-zorder">
      <button type="button" id="freeform-to-front">Front</button>
      <button type="button" id="freeform-to-back">Back</button>
      <button type="button" id="freeform-delete" class="danger">
        Delete
      </button>
    </div>
  </div>

  <div class="grid-decoration-controls" id="grid-decoration-controls" style="display: none">
    <button type="button" id="grid-decoration-delete" class="danger">Delete</button>
  </div>

  <!-- Supabase CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script type="text/javascript" src="src/supabase.js"></script>

  <script type="text/javascript" src="src/globals.js"></script>
  <script type="text/javascript" src="src/utils.js"></script>
  <script type="text/javascript" src="src/entries.js"></script>
  <script type="text/javascript" src="src/iso-geometry.js"></script>
  <script type="text/javascript" src="src/stroke-logic.js"></script>
  <script type="text/javascript" src="src/maze-iso.js"></script>
  <script type="text/javascript" src="src/tile-placement.js"></script>
  <script type="text/javascript" src="src/decoration-library.js"></script>
  <script type="text/javascript" src="src/solver.js"></script>
  <script type="text/javascript" src="src/app.js"></script>
  <script type="text/javascript" src="src/human-colours-en-gb.js"></script>
  <script type="text/javascript" src="src/color-picker.js"></script>
  <script type="text/javascript" src="src/asset-picker.js"></script>

  <!-- UI Toggle Scripts -->
  <script type="text/javascript">
    (function () {
      // Generate maze on page load
      if (typeof initMaze === "function") {
        initMaze();
      }

      // Initialize Supabase client
      if (typeof SupabaseClient !== "undefined" && SupabaseClient.init) {
        SupabaseClient.init();
        console.log("Supabase client initialized");
      }

      // Initialize custom decoration library
      if (
        typeof DecorationLibrary !== "undefined" &&
        DecorationLibrary.init
      ) {
        DecorationLibrary.init();
      }

      // Initialize free-form decoration controls
      (function initFreeFormControls() {
        var scaleSlider = document.getElementById("freeform-scale");
        var scaleValue = document.getElementById("freeform-scale-value");
        var toFrontBtn = document.getElementById("freeform-to-front");
        var toBackBtn = document.getElementById("freeform-to-back");
        var deleteBtn = document.getElementById("freeform-delete");

        if (scaleSlider) {
          scaleSlider.addEventListener("input", function () {
            var val = parseFloat(this.value);
            if (scaleValue) {
              scaleValue.textContent = val.toFixed(2) + "x";
            }
            if (
              typeof TilePlacement !== "undefined" &&
              TilePlacement.scaleFreeForm
            ) {
              TilePlacement.scaleFreeForm(val);
            }
          });
        }

        if (toFrontBtn) {
          toFrontBtn.addEventListener("click", function () {
            if (
              typeof TilePlacement !== "undefined" &&
              TilePlacement.bringFreeFormToFront
            ) {
              TilePlacement.bringFreeFormToFront();
            }
          });
        }

        if (toBackBtn) {
          toBackBtn.addEventListener("click", function () {
            if (
              typeof TilePlacement !== "undefined" &&
              TilePlacement.sendFreeFormToBack
            ) {
              TilePlacement.sendFreeFormToBack();
            }
          });
        }

        if (deleteBtn) {
          deleteBtn.addEventListener("click", function () {
            if (
              typeof TilePlacement !== "undefined" &&
              TilePlacement.deleteSelectedFreeForm
            ) {
              TilePlacement.deleteSelectedFreeForm();
            }
          });
        }
      })();

      // Grid decoration delete button
      (function () {
        var gridDeleteBtn = document.getElementById("grid-decoration-delete");
        if (gridDeleteBtn) {
          gridDeleteBtn.addEventListener("click", function () {
            if (
              typeof TilePlacement !== "undefined" &&
              TilePlacement.deleteSelectedGridDecoration
            ) {
              TilePlacement.deleteSelectedGridDecoration();
            }
          });
        }
      })();

      // Settings panel toggle
      var settingsToggle = document.getElementById("settings-toggle");
      var settingsPanel = document.getElementById("settings-panel");

      if (settingsToggle && settingsPanel) {
        settingsToggle.addEventListener("click", function () {
          settingsPanel.classList.toggle("hidden");
          settingsToggle.classList.toggle("active");
          document.body.classList.toggle("drawer-open");
        });
      }

      // Decoration drawer toggle
      var decorationsToggle = document.getElementById("decorations-toggle");
      var decorationDrawer = document.getElementById("decoration-drawer");

      if (decorationsToggle && decorationDrawer) {
        decorationsToggle.addEventListener("click", function () {
          decorationDrawer.classList.toggle("open");
          decorationsToggle.classList.toggle("active");
          document.body.classList.toggle("decorations-open");
        });
      }

      // Logout button
      var logoutBtn = document.getElementById("logout-btn");
      if (logoutBtn) {
        logoutBtn.addEventListener("click", async function () {
          if (typeof SupabaseClient !== "undefined" && SupabaseClient.signOut) {
            logoutBtn.disabled = true;
            logoutBtn.textContent = "Signing out...";
            await SupabaseClient.signOut();
            logoutBtn.disabled = false;
            logoutBtn.textContent = "Sign Out";
          }
        });
      }

      // Settings panel tabs
      var tabs = document.querySelectorAll(".settings-tab");
      var tabContents = document.querySelectorAll(".settings-tab-content");

      tabs.forEach(function (tab) {
        tab.addEventListener("click", function () {
          var targetTab = this.getAttribute("data-tab");

          // Update tab buttons
          tabs.forEach(function (t) {
            t.classList.remove("active");
          });
          this.classList.add("active");

          // Update tab content
          tabContents.forEach(function (content) {
            content.classList.remove("active");
            if (content.getAttribute("data-tab-content") === targetTab) {
              content.classList.add("active");
            }
          });

          // Refresh lists when switching tabs
          if (targetTab === "maps") {
            renderSavedMapsList();
          } else if (targetTab === "projects") {
            renderProjectsList();
          }
        });
      });

      // Toast notification system
      function showToast(message, type, duration) {
        type = type || "info";
        duration = duration || 4000;

        var container = document.getElementById("toast-container");
        if (!container) return;

        var toast = document.createElement("div");
        toast.className = "toast toast-" + type;

        var icons = {
          success: '<svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>',
          error: '<svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>',
          info: '<svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>'
        };

        toast.innerHTML =
          (icons[type] || icons.info) +
          '<span class="toast-message">' + message + '</span>' +
          '<button class="toast-close" type="button">&times;</button>';

        container.appendChild(toast);

        var closeBtn = toast.querySelector(".toast-close");
        var timeoutId;

        function removeToast() {
          if (timeoutId) clearTimeout(timeoutId);
          toast.classList.add("toast-out");
          setTimeout(function() {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300);
        }

        closeBtn.addEventListener("click", removeToast);
        timeoutId = setTimeout(removeToast, duration);
      }

      // Supabase-based Map Management
      var CURRENT_PROJECT_KEY = "maze-generator-current-project";
      var currentMapId = null; // Track currently loaded map for updates
      var projectsCache = []; // Cache of loaded projects
      var mapsCache = []; // Cache of loaded maps for current project

      // Get current project ID from localStorage (for session persistence)
      function getCurrentProjectId() {
        return localStorage.getItem(CURRENT_PROJECT_KEY) || null;
      }

      function setCurrentProjectIdLocal(projectId) {
        if (projectId) {
          localStorage.setItem(CURRENT_PROJECT_KEY, projectId);
        } else {
          localStorage.removeItem(CURRENT_PROJECT_KEY);
        }
      }

      // Load projects from Supabase
      async function loadProjects() {
        if (typeof SupabaseClient === "undefined") {
          console.error("Supabase not available");
          return [];
        }
        var result = await SupabaseClient.getProjects();
        if (result.error) {
          console.error("Failed to load projects:", result.error);
          return [];
        }
        projectsCache = result.data || [];
        return projectsCache;
      }

      // Load maps for current project from Supabase
      async function loadMapsForProject(projectId) {
        if (!projectId || typeof SupabaseClient === "undefined") {
          mapsCache = [];
          return [];
        }
        var result = await SupabaseClient.getMapsForProject(projectId);
        if (result.error) {
          console.error("Failed to load maps:", result.error);
          mapsCache = [];
          return [];
        }
        mapsCache = result.data || [];
        return mapsCache;
      }

      // Create a new project
      async function createProjectAsync(name) {
        if (typeof SupabaseClient === "undefined") {
          showToast("Supabase not available", "error");
          return null;
        }
        var result = await SupabaseClient.createProject(name);
        if (result.error) {
          showToast("Failed to create project: " + result.error.message, "error");
          return null;
        }
        return result.data;
      }

      // Rename a project
      async function renameProjectAsync(projectId, newName) {
        if (typeof SupabaseClient === "undefined") return;
        var result = await SupabaseClient.updateProject(projectId, { name: newName });
        if (result.error) {
          showToast("Failed to rename project: " + result.error.message, "error");
        }
      }

      // Delete a project
      async function deleteProjectAsync(projectId) {
        if (typeof SupabaseClient === "undefined") return;
        var result = await SupabaseClient.deleteProject(projectId);
        if (result.error) {
          showToast("Failed to delete project: " + result.error.message, "error");
        }
      }

      // Set current project and refresh maps
      async function setCurrentProjectId(projectId) {
        setCurrentProjectIdLocal(projectId);
        await loadMapsForProject(projectId);
        await renderProjectSelector();
        renderSavedMapsList();
        updateMapNameInput();

        // Load border settings for this project
        await loadBorderSettingsForProject(projectId);

        // Save state to Supabase
        saveUserState();
      }

      // Load border settings for a project and restore them
      async function loadBorderSettingsForProject(projectId) {
        if (!projectId || typeof SupabaseClient === "undefined" || !SupabaseClient.getBorderSettings) {
          return;
        }

        var result = await SupabaseClient.getBorderSettings(projectId);
        if (!result.error && result.data) {
          var settings = result.data;
          window.borderAssignments = settings.assignments || {};
          window.borderMarginSixteenths = settings.margin_sixteenths || 8;
          window.bordersCache = window.bordersCache || [];

          // Also update the local variables if the border library has been initialized
          if (typeof borderMarginSixteenths !== "undefined") {
            borderMarginSixteenths = settings.margin_sixteenths || 8;
          }
        } else {
          // Clear border settings if none saved
          window.borderAssignments = {};
          window.borderMarginSixteenths = 8;
        }
      }

      // Save user state to Supabase (debounced)
      var saveUserStateTimeout = null;
      function saveUserState() {
        if (saveUserStateTimeout) clearTimeout(saveUserStateTimeout);
        saveUserStateTimeout = setTimeout(async function() {
          if (typeof SupabaseClient !== "undefined" && SupabaseClient.setUserState) {
            await SupabaseClient.setUserState({
              current_project_id: getCurrentProjectId(),
              current_map_id: currentMapId
            });
          }
        }, 500);
      }

      // Generate thumbnail as blob for upload
      function generateThumbnailBlob() {
        return new Promise(function(resolve) {
          var canvas = document.getElementById("maze");
          if (!canvas) {
            resolve(null);
            return;
          }

          var thumbCanvas = document.createElement("canvas");
          var maxSize = 160;
          var scale = Math.min(maxSize / canvas.width, maxSize / canvas.height);
          thumbCanvas.width = canvas.width * scale;
          thumbCanvas.height = canvas.height * scale;

          var ctx = thumbCanvas.getContext("2d");
          ctx.drawImage(canvas, 0, 0, thumbCanvas.width, thumbCanvas.height);

          thumbCanvas.toBlob(function(blob) {
            resolve(blob);
          }, "image/jpeg", 0.7);
        });
      }

      // Generate map name based on existing maps
      function generateMapName() {
        return "Floor " + (mapsCache.length + 1);
      }

      // Save current map to Supabase
      async function saveCurrentMapAsync(name) {
        if (typeof mazeNodes === "undefined" || !mazeNodes.exportMaze) {
          showToast("No maze to save", "error");
          return null;
        }

        var projectId = getCurrentProjectId();
        if (!projectId) {
          showToast("Please select or create a project first", "error");
          return null;
        }

        if (typeof SupabaseClient === "undefined") {
          showToast("Supabase not available", "error");
          return null;
        }

        var mapName = name || generateMapName();
        var mazeJson = mazeNodes.exportMaze();
        var thumbnail = await generateThumbnailBlob();

        var result = await SupabaseClient.createMap(projectId, mapName, mazeJson, thumbnail);
        if (result.error) {
          showToast("Failed to save map: " + result.error.message, "error");
          return null;
        }

        // Refresh maps cache
        await loadMapsForProject(projectId);
        renderSavedMapsList();
        showToast('Map saved as "' + mapName + '"', "success");

        return result.data;
      }

      // Update existing map
      async function updateCurrentMapAsync() {
        if (!currentMapId) {
          showToast("No map loaded to update", "error");
          return;
        }

        if (typeof mazeNodes === "undefined" || !mazeNodes.exportMaze) {
          showToast("No maze to save", "error");
          return;
        }

        if (typeof SupabaseClient === "undefined") {
          showToast("Supabase not available", "error");
          return;
        }

        var nameInput = document.getElementById("save-map-name");
        var newName = nameInput ? nameInput.value.trim() : "";

        var updates = {
          maze_json: mazeNodes.exportMaze()
        };
        if (newName) {
          updates.name = newName;
        }

        var result = await SupabaseClient.updateMap(currentMapId, updates);
        if (result.error) {
          showToast("Failed to update map: " + result.error.message, "error");
          return;
        }

        // Refresh maps cache
        var projectId = getCurrentProjectId();
        await loadMapsForProject(projectId);
        renderSavedMapsList();

        setCurrentMapDisplay(result.data.id, result.data.name);
        showToast('Map "' + result.data.name + '" updated', "success");
      }

      // Load a map from cache
      async function loadMapAsync(mapId) {
        var map = mapsCache.find(function(m) { return m.id === mapId; });

        if (!map) {
          // Try fetching from Supabase
          if (typeof SupabaseClient !== "undefined") {
            var result = await SupabaseClient.getMap(mapId);
            if (!result.error && result.data) {
              map = result.data;
            }
          }
        }

        if (!map) {
          showToast("Map not found", "error");
          return;
        }

        if (typeof mazeNodes === "undefined" || !mazeNodes.importMaze) {
          showToast("Maze not initialized", "error");
          return;
        }

        // maze_json is stored as JSONB, may be object or string
        var mazeData = typeof map.maze_json === "string" ? map.maze_json : JSON.stringify(map.maze_json);

        if (mazeNodes.importMaze(mazeData)) {
          mazeNodes.loadDecorations().then(function() {
            mazeNodes.draw();
            if (typeof TilePlacement !== "undefined" && TilePlacement.saveCanvasState) {
              TilePlacement.saveCanvasState();
            }
            setCurrentMapDisplay(map.id, map.name);
          });
        } else {
          showToast("Failed to load map", "error");
        }
      }

      // Delete a map
      async function deleteMapAsync(mapId) {
        if (!confirm("Delete this map?")) return;

        if (typeof SupabaseClient === "undefined") {
          showToast("Supabase not available", "error");
          return;
        }

        var result = await SupabaseClient.deleteMap(mapId);
        if (result.error) {
          showToast("Failed to delete map: " + result.error.message, "error");
          return;
        }

        // Clear current map if it was deleted
        if (currentMapId === mapId) {
          clearCurrentMap();
        }

        // Refresh maps cache
        var projectId = getCurrentProjectId();
        await loadMapsForProject(projectId);
        renderSavedMapsList();
        showToast("Map deleted", "success");
      }

      // Rename a map
      async function renameMapAsync(mapId) {
        var map = mapsCache.find(function(m) { return m.id === mapId; });
        if (!map) return;

        var newName = prompt("Enter new name:", map.name);
        if (!newName || !newName.trim()) return;

        if (typeof SupabaseClient === "undefined") {
          showToast("Supabase not available", "error");
          return;
        }

        var result = await SupabaseClient.updateMap(mapId, { name: newName.trim() });
        if (result.error) {
          showToast("Failed to rename map: " + result.error.message, "error");
          return;
        }

        // Refresh maps cache
        var projectId = getCurrentProjectId();
        await loadMapsForProject(projectId);
        renderSavedMapsList();
      }

      function setCurrentMapDisplay(mapId, mapName) {
        var updateBtn = document.getElementById("update-map-btn");
        var nameInput = document.getElementById("save-map-name");

        currentMapId = mapId;

        if (mapId && mapName) {
          if (updateBtn) updateBtn.disabled = false;
          if (nameInput) nameInput.value = mapName;
        } else {
          if (updateBtn) updateBtn.disabled = true;
        }

        // Re-render to update the editing highlight
        renderSavedMapsList();

        // Save state to Supabase
        saveUserState();
      }

      function clearCurrentMap() {
        setCurrentMapDisplay(null, null);
        updateMapNameInput();
      }

      function downloadMap(mapId) {
        var map = mapsCache.find(function(m) { return m.id === mapId; });
        if (!map) {
          showToast("Map not found", "error");
          return;
        }

        if (typeof mazeNodes === "undefined" || !mazeNodes.importMaze) {
          showToast("Maze not initialized", "error");
          return;
        }

        var mazeData = typeof map.maze_json === "string" ? map.maze_json : JSON.stringify(map.maze_json);

        if (mazeNodes.importMaze(mazeData)) {
          mazeNodes.loadDecorations().then(function() {
            mazeNodes.draw();
            if (typeof TilePlacement !== "undefined" && TilePlacement.saveCanvasState) {
              TilePlacement.saveCanvasState();
            }

            try {
              var canvas = document.getElementById("maze");
              var image = canvas.toDataURL("image/png");
              var link = document.createElement("a");
              link.href = image;
              var filename = map.name.replace(/[^a-z0-9]/gi, "_").toLowerCase() + ".png";
              link.download = filename;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            } catch (err) {
              showToast("Cannot export PNG: canvas contains cross-origin images", "error");
              console.error("toDataURL failed:", err);
            }
          });
        } else {
          showToast("Failed to load map", "error");
        }
      }

      function downloadAllMaps() {
        if (mapsCache.length === 0) {
          showToast("No maps to download", "info");
          return;
        }

        if (typeof mazeNodes === "undefined" || !mazeNodes.importMaze) {
          showToast("Maze not initialized", "error");
          return;
        }

        var downloadAllBtn = document.getElementById("download-all-btn");
        if (downloadAllBtn) {
          downloadAllBtn.disabled = true;
          downloadAllBtn.textContent = "Downloading...";
        }

        var currentIndex = 0;
        var totalMaps = mapsCache.length;

        function downloadNext() {
          if (currentIndex >= totalMaps) {
            if (downloadAllBtn) {
              downloadAllBtn.disabled = false;
              downloadAllBtn.textContent = "Download All";
            }
            return;
          }

          var map = mapsCache[currentIndex];
          if (downloadAllBtn) {
            downloadAllBtn.textContent = "Downloading " + (currentIndex + 1) + "/" + totalMaps + "...";
          }

          var mazeData = typeof map.maze_json === "string" ? map.maze_json : JSON.stringify(map.maze_json);

          if (mazeNodes.importMaze(mazeData)) {
            mazeNodes.loadDecorations().then(function() {
              mazeNodes.draw();
              if (typeof TilePlacement !== "undefined" && TilePlacement.saveCanvasState) {
                TilePlacement.saveCanvasState();
              }

              try {
                var canvas = document.getElementById("maze");
                var image = canvas.toDataURL("image/png");
                var link = document.createElement("a");
                link.href = image;
                var filename = map.name.replace(/[^a-z0-9]/gi, "_").toLowerCase() + ".png";
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
              } catch (err) {
                console.error("Failed to export map:", map.name, err);
              }

              currentIndex++;
              setTimeout(downloadNext, 500);
            });
          } else {
            console.error("Failed to load map:", map.name);
            currentIndex++;
            setTimeout(downloadNext, 100);
          }
        }

        downloadNext();
      }

      async function renderProjectSelector() {
        var select = document.getElementById("current-project");
        if (!select) return;

        var currentId = getCurrentProjectId();

        if (projectsCache.length === 0) {
          select.innerHTML = '<option value="">No projects</option>';
          return;
        }

        // If no current project selected, select the first one
        if (!currentId && projectsCache.length > 0) {
          currentId = projectsCache[0].id;
          setCurrentProjectIdLocal(currentId);
        }

        select.innerHTML = projectsCache
          .map(function(p) {
            var selected = p.id === currentId ? " selected" : "";
            return '<option value="' + p.id + '"' + selected + ">" + escapeHtml(p.name) + "</option>";
          })
          .join("");
      }

      async function renderProjectsList() {
        var container = document.getElementById("project-list");
        if (!container) return;

        if (projectsCache.length === 0) {
          container.innerHTML = '<div class="no-saved-maps">No projects yet</div>';
          return;
        }

        container.innerHTML = projectsCache
          .map(function(project) {
            return (
              '<div class="project-item" data-project-id="' + project.id + '">' +
              '<span class="project-name">' + escapeHtml(project.name) + "</span>" +
              '<button type="button" class="rename-project-btn" data-project-id="' + project.id + '">Rename</button>' +
              '<button type="button" class="delete-project-btn" data-project-id="' + project.id + '">Delete</button>' +
              "</div>"
            );
          })
          .join("");

        // Add event listeners
        container.querySelectorAll(".rename-project-btn").forEach(function(btn) {
          btn.addEventListener("click", async function() {
            var projectId = this.getAttribute("data-project-id");
            var project = projectsCache.find(function(p) { return p.id === projectId; });
            if (!project) return;

            var newName = prompt("Enter new name:", project.name);
            if (newName && newName.trim()) {
              await renameProjectAsync(projectId, newName.trim());
              await loadProjects();
              await renderProjectSelector();
              await renderProjectsList();
            }
          });
        });

        container.querySelectorAll(".delete-project-btn").forEach(function(btn) {
          btn.addEventListener("click", async function() {
            var projectId = this.getAttribute("data-project-id");
            if (confirm("Delete this project and all its maps?")) {
              await deleteProjectAsync(projectId);
              await loadProjects();

              // If deleted project was current, switch to first available
              if (getCurrentProjectId() === projectId) {
                var newProjectId = projectsCache.length > 0 ? projectsCache[0].id : null;
                await setCurrentProjectId(newProjectId);
              }

              await renderProjectSelector();
              await renderProjectsList();
            }
          });
        });
      }

      function renderSavedMapsList() {
        var container = document.getElementById("saved-maps-list");
        if (!container) return;

        if (mapsCache.length === 0) {
          container.innerHTML = '<div class="no-saved-maps">No saved maps yet</div>';
          return;
        }

        container.innerHTML = mapsCache
          .map(function(map) {
            var date = new Date(map.created_at);
            var dateStr = date.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
            var isEditing = currentMapId === map.id;
            var editingClass = isEditing ? " editing" : "";

            return (
              '<div class="saved-map-item' + editingClass + '" data-map-id="' + map.id + '">' +
              '<div class="saved-map-content">' +
              '<div class="saved-map-thumbnail">' +
              (map.thumbnail_url ? '<img src="' + map.thumbnail_url + '" alt="">' : "") +
              "</div>" +
              '<div class="saved-map-info">' +
              '<div class="saved-map-name">' + escapeHtml(map.name) + "</div>" +
              '<div class="saved-map-meta">' + dateStr + "</div>" +
              "</div>" +
              "</div>" +
              '<div class="saved-map-actions">' +
              '<button type="button" class="download-btn" data-map-id="' + map.id + '">Download</button>' +
              '<button type="button" class="rename-btn" data-map-id="' + map.id + '">Rename</button>' +
              '<button type="button" class="delete-btn" data-map-id="' + map.id + '">Delete</button>' +
              "</div>" +
              "</div>"
            );
          })
          .join("");

        // Add click handlers
        container.querySelectorAll(".saved-map-item").forEach(function(item) {
          item.addEventListener("click", function(e) {
            if (
              e.target.classList.contains("download-btn") ||
              e.target.classList.contains("rename-btn") ||
              e.target.classList.contains("delete-btn")
            ) {
              return;
            }
            var mapId = this.getAttribute("data-map-id");
            loadMapAsync(mapId);
          });
        });

        container.querySelectorAll(".rename-btn").forEach(function(btn) {
          btn.addEventListener("click", function(e) {
            e.stopPropagation();
            renameMapAsync(this.getAttribute("data-map-id"));
          });
        });

        container.querySelectorAll(".delete-btn").forEach(function(btn) {
          btn.addEventListener("click", function(e) {
            e.stopPropagation();
            deleteMapAsync(this.getAttribute("data-map-id"));
          });
        });

        container.querySelectorAll(".download-btn").forEach(function(btn) {
          btn.addEventListener("click", function(e) {
            e.stopPropagation();
            downloadMap(this.getAttribute("data-map-id"));
          });
        });
      }

      function escapeHtml(text) {
        var div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Save map button
      var saveMapBtn = document.getElementById("save-map-btn");
      var saveMapNameInput = document.getElementById("save-map-name");

      function updateMapNameInput() {
        if (saveMapNameInput) {
          saveMapNameInput.value = generateMapName();
        }
      }

      if (saveMapBtn) {
        saveMapBtn.addEventListener("click", async function() {
          var name = saveMapNameInput ? saveMapNameInput.value.trim() : "";
          saveMapBtn.disabled = true;

          var saved = await saveCurrentMapAsync(name);

          saveMapBtn.disabled = false;

          if (saved) {
            setCurrentMapDisplay(saved.id, saved.name);
          }
        });
      }

      // Download All button
      var downloadAllBtn = document.getElementById("download-all-btn");
      if (downloadAllBtn) {
        downloadAllBtn.addEventListener("click", downloadAllMaps);
      }

      // Update map button
      var updateMapBtn = document.getElementById("update-map-btn");
      if (updateMapBtn) {
        updateMapBtn.addEventListener("click", async function() {
          updateMapBtn.disabled = true;

          await updateCurrentMapAsync();

          updateMapBtn.disabled = false;
        });
      }

      // Project selector event listeners
      var projectSelector = document.getElementById("current-project");
      if (projectSelector) {
        projectSelector.addEventListener("change", async function() {
          await setCurrentProjectId(this.value);
        });
      }

      // New project button (in maps tab)
      var newProjectBtn = document.getElementById("new-project-btn");
      if (newProjectBtn) {
        newProjectBtn.addEventListener("click", async function() {
          var name = prompt("Enter project name:");
          if (name && name.trim()) {
            var project = await createProjectAsync(name.trim());
            if (project) {
              await loadProjects();
              await setCurrentProjectId(project.id);
              await renderProjectsList();
            }
          }
        });
      }

      // Add project button (in projects tab)
      var addProjectBtn = document.getElementById("add-project-btn");
      var newProjectNameInput = document.getElementById("new-project-name");
      if (addProjectBtn) {
        addProjectBtn.addEventListener("click", async function() {
          var name = newProjectNameInput ? newProjectNameInput.value.trim() : "";
          if (name) {
            var project = await createProjectAsync(name);
            if (project) {
              if (newProjectNameInput) newProjectNameInput.value = "";
              await loadProjects();
              await renderProjectSelector();
              await renderProjectsList();
            }
          } else {
            showToast("Please enter a project name", "error");
          }
        });
      }

      // Initial load of projects and maps
      (async function initProjectsAndMaps() {
        await loadProjects();

        // Try to restore state from Supabase first
        var savedState = null;
        var savedMapId = null;
        if (typeof SupabaseClient !== "undefined" && SupabaseClient.getUserState) {
          var stateResult = await SupabaseClient.getUserState();
          if (!stateResult.error && stateResult.data) {
            savedState = stateResult.data;
          }
        }

        // Determine current project
        var currentProjectId = savedState?.current_project_id || getCurrentProjectId();

        // If we have a saved project ID, verify it exists
        if (currentProjectId) {
          var projectExists = projectsCache.some(function(p) { return p.id === currentProjectId; });
          if (!projectExists) {
            currentProjectId = null;
          }
        }

        // If no valid project, select first one if available
        if (!currentProjectId && projectsCache.length > 0) {
          currentProjectId = projectsCache[0].id;
        }

        if (currentProjectId) {
          setCurrentProjectIdLocal(currentProjectId);
          await loadMapsForProject(currentProjectId);
          await loadBorderSettingsForProject(currentProjectId);
        }

        await renderProjectSelector();
        await renderProjectsList();
        renderSavedMapsList();
        updateMapNameInput();

        // Restore the map that was being edited
        if (savedState?.current_map_id) {
          var mapToLoad = mapsCache.find(function(m) { return m.id === savedState.current_map_id; });
          if (mapToLoad) {
            await loadMapAsync(savedState.current_map_id);
          }
        }
      })();

      // Database Export/Import
      async function exportDatabase() {
        // Fetch all projects and maps from Supabase
        var projectsResult = await SupabaseClient.getProjects();
        var allProjects = projectsResult.data || [];

        // Fetch maps for each project
        var allMaps = [];
        for (var i = 0; i < allProjects.length; i++) {
          var mapsResult = await SupabaseClient.getMapsForProject(allProjects[i].id);
          if (mapsResult.data) {
            allMaps = allMaps.concat(mapsResult.data);
          }
        }

        var data = {
          version: 3,
          exportDate: new Date().toISOString(),
          projects: allProjects,
          maps: allMaps,
          currentProject: currentProjectId,
          customDecorations:
            typeof DecorationLibrary !== "undefined"
              ? DecorationLibrary.exportLibrary()
              : null,
        };

        var json = JSON.stringify(data, null, 2);
        var blob = new Blob([json], {type: "application/json"});
        var url = URL.createObjectURL(blob);

        var link = document.createElement("a");
        link.href = url;
        var date = new Date().toISOString().split("T")[0];
        link.download = "maze-generator-backup-" + date + ".json";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      async function importDatabase(file) {
        var reader = new FileReader();
        reader.onload = async function (e) {
          try {
            var data = JSON.parse(e.target.result);

            if (!data.projects || !data.maps) {
              showToast("Invalid backup file format", "error");
              return;
            }

            var mapCount = data.maps ? data.maps.length : 0;
            var projectCount = data.projects ? data.projects.length : 0;

            var confirmMsg =
              "Import " +
              mapCount +
              " maps and " +
              projectCount +
              " projects?\n\n";
            confirmMsg += "Choose how to handle existing data:\n";
            confirmMsg += " OK = Merge (add to existing)\n";
            confirmMsg += " Cancel = Abort import";

            if (!confirm(confirmMsg)) {
              return;
            }

            // Get existing project IDs to avoid duplicates
            var existingResult = await SupabaseClient.getProjects();
            var existingProjects = existingResult.data || [];
            var existingProjectIds = existingProjects.map(function (p) {
              return p.id;
            });

            // Import new projects
            var projectIdMap = {}; // Map old IDs to new IDs for imported projects
            var importedProjects = 0;
            for (var i = 0; i < data.projects.length; i++) {
              var project = data.projects[i];
              if (existingProjectIds.indexOf(project.id) === -1) {
                var result = await SupabaseClient.createProject(project.name);
                if (result.data) {
                  projectIdMap[project.id] = result.data.id;
                  importedProjects++;
                }
              } else {
                // Project already exists, use existing ID
                projectIdMap[project.id] = project.id;
              }
            }

            // Get existing map IDs
            var allExistingMaps = [];
            for (var i = 0; i < existingProjects.length; i++) {
              var mapsResult = await SupabaseClient.getMapsForProject(existingProjects[i].id);
              if (mapsResult.data) {
                allExistingMaps = allExistingMaps.concat(mapsResult.data);
              }
            }
            var existingMapIds = allExistingMaps.map(function (m) {
              return m.id;
            });

            // Import new maps
            var importedMaps = 0;
            for (var i = 0; i < data.maps.length; i++) {
              var map = data.maps[i];
              if (existingMapIds.indexOf(map.id) === -1) {
                var newProjectId = projectIdMap[map.project_id] || map.project_id;
                var mazeJson = typeof map.maze_json === "string"
                  ? map.maze_json
                  : JSON.stringify(map.maze_json);
                var result = await SupabaseClient.createMap({
                  project_id: newProjectId,
                  name: map.name,
                  maze_json: mazeJson,
                  thumbnail_url: map.thumbnail_url
                });
                if (result.data) {
                  importedMaps++;
                }
              }
            }

            // Import custom decorations if present
            if (
              data.customDecorations &&
              typeof DecorationLibrary !== "undefined"
            ) {
              DecorationLibrary.importLibrary(data.customDecorations);
            }

            // Refresh caches and UI
            await loadProjects();
            if (currentProjectId) {
              await loadMapsForProject(currentProjectId);
            }
            await renderProjectSelector();
            await renderProjectsList();
            renderSavedMapsList();
            updateMapNameInput();

            var decorationMsg = data.customDecorations
              ? " and custom decorations"
              : "";
            showToast(
              "Import complete! Added " +
              importedMaps +
              " maps and " +
              importedProjects +
              " projects" +
              decorationMsg,
              "success"
            );
          } catch (err) {
            console.error("Import failed:", err);
            showToast("Failed to import: " + err.message, "error");
          }
        };
        reader.readAsText(file);
      }

      // Export database button
      var exportDbBtn = document.getElementById("export-database-btn");
      if (exportDbBtn) {
        exportDbBtn.addEventListener("click", exportDatabase);
      }

      // Import database button
      var importDbBtn = document.getElementById("import-database-btn");
      var importDbFile = document.getElementById("import-database-file");
      if (importDbBtn && importDbFile) {
        importDbBtn.addEventListener("click", function () {
          importDbFile.click();
        });
        importDbFile.addEventListener("change", function () {
          if (this.files && this.files[0]) {
            importDatabase(this.files[0]);
            this.value = ""; // Reset for next import
          }
        });
      }

      // FAB - Generate New Maze button
      var fabGenerate = document.getElementById("fab-generate");
      if (fabGenerate) {
        fabGenerate.addEventListener("click", function () {
          if (typeof initMaze === "function") {
            initMaze();
            clearCurrentMap();
          }
        });
      }

      // FAB - Download Map button
      var fabDownload = document.getElementById("fab-download");
      if (fabDownload) {
        fabDownload.addEventListener("click", function () {
          try {
            var canvas = document.getElementById("maze");
            var image = canvas.toDataURL("image/png");

            var link = document.createElement("a");
            link.href = image;
            link.download = "maze.png";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          } catch (err) {
            showToast("Cannot export PNG: canvas contains cross-origin images", "error");
            console.error("toDataURL failed:", err);
          }
        });
      }

      // ============================================
      // Publishing Mode
      // ============================================
      var publishingMode = false;
      var prePublishState = null; // Store state before publishing for cancel

      var fabPublish = document.getElementById("fab-publish");
      var publishingToolbar = document.getElementById("publishing-toolbar");
      var publishingAccept = document.getElementById("publishing-accept");
      var publishingCancel = document.getElementById("publishing-cancel");
      var publishingExport = document.getElementById("publishing-export");

      function enterPublishingMode() {
        if (publishingMode) return;

        // Save current state for potential cancel
        if (typeof mazeNodes !== "undefined" && mazeNodes.exportMaze) {
          prePublishState = mazeNodes.exportMaze();
        }

        publishingMode = true;
        document.body.classList.add("publishing-mode");
        if (publishingToolbar) publishingToolbar.style.display = "block";
      }

      function exitPublishingMode(accept) {
        if (!publishingMode) return;

        if (!accept && prePublishState) {
          // Cancel - restore previous state
          if (typeof mazeNodes !== "undefined" && mazeNodes.importMaze) {
            mazeNodes.importMaze(prePublishState);
            mazeNodes.loadDecorations().then(function() {
              mazeNodes.draw();
            });
          }
        }

        publishingMode = false;
        prePublishState = null;
        document.body.classList.remove("publishing-mode");
        if (publishingToolbar) publishingToolbar.style.display = "none";
      }

      function exportPublishedMap() {
        // Check if we have border assignments for batch export
        if (window.borderAssignments && Object.keys(window.borderAssignments).length > 0) {
          batchExportWithBorders();
        } else {
          // Single map export (no borders)
          try {
            var canvas = document.getElementById("maze");
            var image = canvas.toDataURL("image/png");
            var link = document.createElement("a");
            link.href = image;
            link.download = "maze-published.png";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          } catch (err) {
            showToast("Cannot export PNG: canvas contains cross-origin images", "error");
            console.error("toDataURL failed:", err);
          }
        }
      }

      // Batch export with borders - 11x8.5" landscape at 300 DPI = 3300x2550 pixels
      var PRINT_WIDTH = 3300;
      var PRINT_HEIGHT = 2550;
      var exportCancelled = false;
      var borderMarginSixteenths = 8; // Default 8/16 = 1/2 inch

      // Margin slider elements
      var borderMarginSlider = document.getElementById("border-margin-slider");
      var borderMarginValue = document.getElementById("border-margin-value");

      function formatMarginFraction(sixteenths) {
        if (sixteenths === 0) return '0"';
        if (sixteenths === 16) return '1"';
        // Simplify the fraction
        var gcd = function(a, b) { return b ? gcd(b, a % b) : a; };
        var divisor = gcd(sixteenths, 16);
        var num = sixteenths / divisor;
        var den = 16 / divisor;
        return num + "/" + den + '"';
      }

      if (borderMarginSlider) {
        borderMarginSlider.addEventListener("input", function() {
          borderMarginSixteenths = parseInt(this.value, 10);
          if (borderMarginValue) {
            borderMarginValue.textContent = formatMarginFraction(borderMarginSixteenths);
          }
        });
      }

      // Progress modal elements
      var exportProgressOverlay = document.getElementById("export-progress-overlay");
      var exportProgressFill = document.getElementById("export-progress-fill");
      var exportProgressText = document.getElementById("export-progress-text");
      var exportProgressCancel = document.getElementById("export-progress-cancel");

      function showExportProgress() {
        exportCancelled = false;
        if (exportProgressOverlay) exportProgressOverlay.classList.remove("hidden");
        if (exportProgressFill) exportProgressFill.style.width = "0%";
        if (exportProgressText) exportProgressText.textContent = "Preparing...";
      }

      function hideExportProgress() {
        if (exportProgressOverlay) exportProgressOverlay.classList.add("hidden");
      }

      function updateExportProgress(current, total, mapName) {
        var percent = Math.round((current / total) * 100);
        if (exportProgressFill) exportProgressFill.style.width = percent + "%";
        if (exportProgressText) exportProgressText.textContent = "Exporting " + current + " of " + total + ": " + mapName;
      }

      if (exportProgressCancel) {
        exportProgressCancel.addEventListener("click", function() {
          exportCancelled = true;
          hideExportProgress();
        });
      }

      async function batchExportWithBorders() {
        var assignments = window.borderAssignments;
        var borders = window.bordersCache || [];

        if (!assignments || Object.keys(assignments).length === 0) {
          showToast("No border assignments. Open Borders panel first.", "error");
          return;
        }

        var mapIds = Object.keys(assignments);
        var totalMaps = mapIds.length;

        showExportProgress();

        // Store current map state to restore later
        var currentState = null;
        if (typeof mazeNodes !== "undefined" && mazeNodes.exportMaze) {
          currentState = mazeNodes.exportMaze();
        }

        var exportedCount = 0;
        var failedCount = 0;

        for (var i = 0; i < mapIds.length; i++) {
          if (exportCancelled) {
            showToast("Export cancelled", "info");
            break;
          }

          var mapId = mapIds[i];
          var borderId = assignments[mapId];
          var map = mapsCache.find(function(m) { return m.id === mapId; });
          var border = borders.find(function(b) { return b.id === borderId; });

          if (!map) {
            console.warn("Map not found:", mapId);
            failedCount++;
            continue;
          }

          updateExportProgress(i + 1, totalMaps, map.name || "Map " + (i + 1));

          try {
            // Load the map
            var mazeData = typeof map.maze_json === "string" ? map.maze_json : JSON.stringify(map.maze_json);
            mazeNodes.importMaze(mazeData);
            await mazeNodes.loadDecorations();
            mazeNodes.draw();

            // Wait for canvas to be fully painted
            await new Promise(function(resolve) {
              requestAnimationFrame(function() {
                requestAnimationFrame(resolve);
              });
            });

            // Create composite image
            var compositeCanvas = document.createElement("canvas");
            compositeCanvas.width = PRINT_WIDTH;
            compositeCanvas.height = PRINT_HEIGHT;
            var ctx = compositeCanvas.getContext("2d");

            // Fill with white background
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, PRINT_WIDTH, PRINT_HEIGHT);

            // Draw border FIRST (as background frame)
            if (border && border.image_url) {
              await new Promise(function(resolve, reject) {
                var borderImg = new Image();
                borderImg.crossOrigin = "anonymous";
                borderImg.onload = function() {
                  ctx.drawImage(borderImg, 0, 0, PRINT_WIDTH, PRINT_HEIGHT);
                  resolve();
                };
                borderImg.onerror = function() {
                  console.warn("Failed to load border image:", border.image_url);
                  resolve(); // Continue without border
                };
                borderImg.src = border.image_url;
              });
            }

            // Draw maze centered on top of border
            var mazeCanvas = document.getElementById("maze");
            console.log("Maze canvas dimensions:", mazeCanvas.width, "x", mazeCanvas.height);
            // Calculate padding: 1/16" = 18.75px at 300 DPI
            var marginValue = window.borderMarginSixteenths !== undefined ? window.borderMarginSixteenths : borderMarginSixteenths;
            var padding = Math.round(marginValue * 18.75);
            var maxMazeWidth = PRINT_WIDTH - padding * 2;
            var maxMazeHeight = PRINT_HEIGHT - padding * 2;

            var mazeAspect = mazeCanvas.width / mazeCanvas.height;
            var targetAspect = maxMazeWidth / maxMazeHeight;

            var drawWidth, drawHeight;
            if (mazeAspect > targetAspect) {
              // Maze is wider - fit to width
              drawWidth = maxMazeWidth;
              drawHeight = maxMazeWidth / mazeAspect;
            } else {
              // Maze is taller - fit to height
              drawHeight = maxMazeHeight;
              drawWidth = maxMazeHeight * mazeAspect;
            }

            var drawX = (PRINT_WIDTH - drawWidth) / 2;
            var drawY = (PRINT_HEIGHT - drawHeight) / 2;

            ctx.drawImage(mazeCanvas, drawX, drawY, drawWidth, drawHeight);

            // Download the composite
            var filename = (map.name || "maze-" + (i + 1)).replace(/[^a-zA-Z0-9-_ ]/g, "") + ".png";
            var link = document.createElement("a");
            link.href = compositeCanvas.toDataURL("image/png");
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            exportedCount++;

            // Small delay between downloads to avoid browser throttling
            if (i < mapIds.length - 1) {
              await new Promise(function(resolve) { setTimeout(resolve, 500); });
            }

          } catch (err) {
            console.error("Failed to export map:", map.name, err);
            failedCount++;
          }
        }

        hideExportProgress();

        // Restore original map state
        if (currentState) {
          mazeNodes.importMaze(currentState);
          await mazeNodes.loadDecorations();
          mazeNodes.draw();
        }

        if (!exportCancelled) {
          if (failedCount > 0) {
            showToast("Exported " + exportedCount + " maps (" + failedCount + " failed)", "info");
          } else {
            showToast("Exported " + exportedCount + " maps successfully!", "success");
          }
        }
      }

      // Event listeners
      if (fabPublish) {
        fabPublish.addEventListener("click", enterPublishingMode);
      }
      if (publishingAccept) {
        publishingAccept.addEventListener("click", function() {
          exitPublishingMode(true);
        });
      }
      if (publishingCancel) {
        publishingCancel.addEventListener("click", function() {
          exitPublishingMode(false);
        });
      }
      if (publishingExport) {
        publishingExport.addEventListener("click", exportPublishedMap);
      }

      // ============================================
      // Border Library
      // ============================================
      var borderLibraryModal = document.getElementById("border-library-modal");
      var borderLibraryClose = document.getElementById("border-library-close");
      var borderLibraryGrid = document.getElementById("border-library-grid");
      var borderUploadZone = document.getElementById("border-upload-zone");
      var borderFileInput = document.getElementById("border-file-input");
      var browseBordersBtn = document.getElementById("browse-borders-btn");
      var publishingBordersBtn = document.getElementById("publishing-borders");
      var singleModeHint = document.getElementById("single-mode-hint");
      var borderPreviewGrid = document.getElementById("border-preview-grid");
      var borderApplyBtn = document.getElementById("border-apply-btn");
      var borderCancelBtn = document.getElementById("border-cancel-btn");
      var previewRerollAllBtn = document.getElementById("preview-reroll-all");

      var bordersCache = []; // Cache of loaded borders
      var selectedBorderIds = []; // IDs of selected borders for assignment
      var borderAssignments = {}; // { mapId: borderId }
      var assignmentMode = "random"; // "random" or "single"

      async function openBorderLibrary() {
        if (borderLibraryModal) {
          borderLibraryModal.classList.remove("hidden");

          // Try to load saved settings for this project
          var projectId = getCurrentProjectId();
          var savedSettings = null;

          if (projectId && typeof SupabaseClient !== "undefined" && SupabaseClient.getBorderSettings) {
            var result = await SupabaseClient.getBorderSettings(projectId);
            if (!result.error && result.data) {
              savedSettings = result.data;
            }
          }

          if (savedSettings) {
            // Restore saved settings
            selectedBorderIds = savedSettings.selected_border_ids || [];
            borderAssignments = savedSettings.assignments || {};
            assignmentMode = savedSettings.assignment_mode || "random";
            borderMarginSixteenths = savedSettings.margin_sixteenths || 8;

            // Update UI to reflect saved settings
            var radioToCheck = document.querySelector('input[name="assignment-mode"][value="' + assignmentMode + '"]');
            if (radioToCheck) radioToCheck.checked = true;
            if (singleModeHint) singleModeHint.style.display = assignmentMode === "single" ? "block" : "none";
            if (borderMarginSlider) borderMarginSlider.value = borderMarginSixteenths;
            if (borderMarginValue) borderMarginValue.textContent = formatMarginFraction(borderMarginSixteenths);

            // Also restore window values
            window.borderAssignments = borderAssignments;
            window.borderMarginSixteenths = borderMarginSixteenths;
          } else {
            // Reset to defaults
            selectedBorderIds = [];
            borderAssignments = {};
            assignmentMode = "random";
            borderMarginSixteenths = 8;
            var radioRandom = document.querySelector('input[name="assignment-mode"][value="random"]');
            if (radioRandom) radioRandom.checked = true;
            if (singleModeHint) singleModeHint.style.display = "none";
            if (borderMarginSlider) borderMarginSlider.value = 8;
            if (borderMarginValue) borderMarginValue.textContent = '1/2"';
          }

          await loadBorders();

          updatePreview();
          updateApplyButton();
        }
      }

      function closeBorderLibrary() {
        if (borderLibraryModal) {
          borderLibraryModal.classList.add("hidden");
        }
      }

      async function loadBorders() {
        if (!borderLibraryGrid) return;

        borderLibraryGrid.innerHTML = '<div class="border-library-loading">Loading borders...</div>';

        if (typeof SupabaseClient === "undefined") {
          borderLibraryGrid.innerHTML = '<div class="border-library-empty">Supabase not initialized. Please check your configuration.</div>';
          return;
        }

        var result = await SupabaseClient.getBorders();

        if (result.error) {
          console.error("Error loading borders:", result.error);
          borderLibraryGrid.innerHTML = '<div class="border-library-empty">Error loading borders: ' + result.error.message + '</div>';
          return;
        }

        bordersCache = result.data || [];

        if (bordersCache.length === 0) {
          borderLibraryGrid.innerHTML = '<div class="border-library-empty">No borders uploaded yet. Upload some border images to get started!</div>';
          updatePreview();
          return;
        }

        renderBorders();
        updatePreview();
      }

      function renderBorders() {
        if (!borderLibraryGrid) return;

        borderLibraryGrid.innerHTML = "";

        bordersCache.forEach(function(border) {
          var item = document.createElement("div");
          item.className = "border-item selectable";
          item.dataset.borderId = border.id;
          if (selectedBorderIds.indexOf(border.id) !== -1) {
            item.classList.add("selected");
          }

          // Checkbox overlay
          var checkbox = document.createElement("div");
          checkbox.className = "border-item-checkbox";
          checkbox.innerHTML = '<svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>';

          var img = document.createElement("img");
          img.src = border.image_url;
          img.alt = border.name;
          img.loading = "lazy";

          var actions = document.createElement("div");
          actions.className = "border-item-actions";

          var deleteBtn = document.createElement("button");
          deleteBtn.className = "border-item-delete";
          deleteBtn.innerHTML = "&times;";
          deleteBtn.title = "Delete border";
          deleteBtn.addEventListener("click", function(e) {
            e.stopPropagation();
            deleteBorder(border.id, border.name);
          });

          var nameLabel = document.createElement("div");
          nameLabel.className = "border-item-name";
          nameLabel.textContent = border.name;

          actions.appendChild(deleteBtn);
          item.appendChild(checkbox);
          item.appendChild(img);
          item.appendChild(actions);
          item.appendChild(nameLabel);

          item.addEventListener("click", function() {
            toggleBorderSelection(border.id);
          });

          borderLibraryGrid.appendChild(item);
        });
      }

      function toggleBorderSelection(borderId) {
        var idx = selectedBorderIds.indexOf(borderId);
        var isSelecting = idx === -1;

        if (assignmentMode === "single") {
          // In single mode, only allow one selection at a time
          if (isSelecting) {
            // Deselect all others first
            selectedBorderIds.forEach(function(oldId) {
              var oldItem = borderLibraryGrid.querySelector('[data-border-id="' + oldId + '"]');
              if (oldItem) oldItem.classList.remove("selected");
            });
            selectedBorderIds = [borderId];
          } else {
            // Clicking the selected one deselects it
            selectedBorderIds = [];
          }
        } else {
          // Random mode - allow multiple selections
          if (isSelecting) {
            selectedBorderIds.push(borderId);
          } else {
            selectedBorderIds.splice(idx, 1);
          }
        }

        // Update visual state
        var item = borderLibraryGrid.querySelector('[data-border-id="' + borderId + '"]');
        if (item) {
          item.classList.toggle("selected", isSelecting);
        }

        // Regenerate assignments and update preview
        generateBorderAssignments();
        updatePreview();
        updateApplyButton();
      }

      function generateBorderAssignments() {
        borderAssignments = {};

        if (mapsCache.length === 0) return;

        if (assignmentMode === "single") {
          // Use the first (and only) selected border in single mode
          var singleId = selectedBorderIds.length > 0 ? selectedBorderIds[0] : null;
          if (singleId) {
            mapsCache.forEach(function(map) {
              borderAssignments[map.id] = singleId;
            });
          }
        } else {
          // Random assignment from selected borders
          if (selectedBorderIds.length === 0) return;

          mapsCache.forEach(function(map) {
            var randomIdx = Math.floor(Math.random() * selectedBorderIds.length);
            borderAssignments[map.id] = selectedBorderIds[randomIdx];
          });
        }
      }

      function rerollSingleAssignment(mapId) {
        if (assignmentMode === "single") return; // Can't reroll in single mode
        if (selectedBorderIds.length === 0) return;

        var randomIdx = Math.floor(Math.random() * selectedBorderIds.length);
        borderAssignments[mapId] = selectedBorderIds[randomIdx];
        updatePreview();
      }

      function rerollAllAssignments() {
        generateBorderAssignments();
        updatePreview();
      }

      function updatePreview() {
        if (!borderPreviewGrid) return;

        if (mapsCache.length === 0) {
          borderPreviewGrid.innerHTML = '<div class="border-preview-empty">No maps in current project</div>';
          return;
        }

        var hasAssignments = Object.keys(borderAssignments).length > 0;
        if (!hasAssignments) {
          borderPreviewGrid.innerHTML = '<div class="border-preview-empty">Select borders to see preview</div>';
          return;
        }

        borderPreviewGrid.innerHTML = "";

        mapsCache.forEach(function(map) {
          var borderId = borderAssignments[map.id];
          var border = bordersCache.find(function(b) { return b.id === borderId; });

          var item = document.createElement("div");
          item.className = "border-preview-item";
          item.dataset.mapId = map.id;

          // Map thumbnail (placeholder - we'll use a simple background)
          var mapThumb = document.createElement("div");
          mapThumb.className = "map-thumbnail";
          mapThumb.style.background = "#fff";
          mapThumb.style.display = "flex";
          mapThumb.style.alignItems = "center";
          mapThumb.style.justifyContent = "center";
          mapThumb.style.fontSize = "10px";
          mapThumb.style.color = "#999";
          mapThumb.textContent = "Map";

          // Border image overlay
          if (border) {
            var borderImg = document.createElement("img");
            borderImg.className = "border-img";
            borderImg.src = border.image_url;
            borderImg.alt = border.name;
            item.appendChild(borderImg);
          }

          // Map name label
          var nameLabel = document.createElement("div");
          nameLabel.className = "map-name";
          nameLabel.textContent = map.name;

          // Re-roll button (only in random mode)
          if (assignmentMode === "random") {
            var rerollBtn = document.createElement("button");
            rerollBtn.className = "reroll-btn";
            rerollBtn.title = "Re-roll border";
            rerollBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M17.65 6.35A7.958 7.958 0 0012 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0112 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>';
            rerollBtn.addEventListener("click", function(e) {
              e.stopPropagation();
              rerollSingleAssignment(map.id);
            });
            item.appendChild(rerollBtn);
          }

          item.appendChild(mapThumb);
          item.appendChild(nameLabel);

          borderPreviewGrid.appendChild(item);
        });
      }

      function updateApplyButton() {
        if (!borderApplyBtn) return;

        var canApply = Object.keys(borderAssignments).length > 0;
        borderApplyBtn.disabled = !canApply;
      }

      async function applyBorderAssignments() {
        // Store assignments for export/batch processing
        window.borderAssignments = borderAssignments;
        window.bordersCache = bordersCache;
        window.borderMarginSixteenths = borderMarginSixteenths;

        // Save to Supabase
        var projectId = getCurrentProjectId();
        if (projectId && typeof SupabaseClient !== "undefined" && SupabaseClient.saveBorderSettings) {
          var singleId = assignmentMode === "single" && selectedBorderIds.length > 0 ? selectedBorderIds[0] : null;
          var settings = {
            margin_sixteenths: borderMarginSixteenths,
            assignment_mode: assignmentMode,
            single_border_id: singleId,
            selected_border_ids: selectedBorderIds,
            assignments: borderAssignments
          };
          var result = await SupabaseClient.saveBorderSettings(projectId, settings);
          if (result.error) {
            console.warn("Failed to save border settings:", result.error);
          }
        }

        var marginText = formatMarginFraction(borderMarginSixteenths);
        var assignmentCount = Object.keys(borderAssignments).length;
        showToast("Border assignments saved (" + assignmentCount + " maps, " + marginText + " margin)", "success");
        closeBorderLibrary();
      }

      async function deleteBorder(id, name) {
        if (!confirm('Delete border "' + name + '"? This cannot be undone.')) {
          return;
        }

        if (typeof SupabaseClient === "undefined") {
          showToast("Supabase not initialized", "error");
          return;
        }

        var result = await SupabaseClient.deleteBorder(id);

        if (result.error) {
          showToast("Error deleting border: " + result.error.message, "error");
          return;
        }

        // Remove from selected if was selected
        var idx = selectedBorderIds.indexOf(id);
        if (idx !== -1) {
          selectedBorderIds.splice(idx, 1);
        }

        showToast("Border deleted", "success");
        loadBorders();
      }

      async function uploadBorders(files) {
        if (!files || files.length === 0) return;

        if (typeof SupabaseClient === "undefined") {
          showToast("Supabase not initialized", "error");
          return;
        }

        var uploadedCount = 0;
        for (var i = 0; i < files.length; i++) {
          var file = files[i];

          // Validate file type
          if (!file.type.match(/^image\/(png|jpeg)$/)) {
            showToast("Invalid file type: " + file.name + ". Only PNG and JPEG allowed.", "error");
            continue;
          }

          // Use filename without extension as name
          var name = file.name.replace(/\.[^/.]+$/, "");

          var result = await SupabaseClient.uploadBorder(file, name);

          if (result.error) {
            showToast("Error uploading " + file.name + ": " + result.error.message, "error");
          } else {
            uploadedCount++;
          }
        }

        if (uploadedCount > 0) {
          showToast("Uploaded " + uploadedCount + " border" + (uploadedCount > 1 ? "s" : ""), "success");
        }

        loadBorders();
      }

      // Event listeners for border library
      if (publishingBordersBtn) {
        publishingBordersBtn.addEventListener("click", openBorderLibrary);
      }

      if (borderLibraryClose) {
        borderLibraryClose.addEventListener("click", closeBorderLibrary);
      }

      if (borderCancelBtn) {
        borderCancelBtn.addEventListener("click", closeBorderLibrary);
      }

      if (borderApplyBtn) {
        borderApplyBtn.addEventListener("click", applyBorderAssignments);
      }

      if (previewRerollAllBtn) {
        previewRerollAllBtn.addEventListener("click", rerollAllAssignments);
      }

      // Assignment mode toggle
      var assignmentModeRadios = document.querySelectorAll('input[name="assignment-mode"]');
      assignmentModeRadios.forEach(function(radio) {
        radio.addEventListener("change", function() {
          assignmentMode = this.value;
          if (singleModeHint) {
            singleModeHint.style.display = assignmentMode === "single" ? "block" : "none";
          }
          // When switching to single mode with multiple selected, keep only the first
          if (assignmentMode === "single" && selectedBorderIds.length > 1) {
            var keepId = selectedBorderIds[0];
            selectedBorderIds.forEach(function(id) {
              if (id !== keepId) {
                var item = borderLibraryGrid.querySelector('[data-border-id="' + id + '"]');
                if (item) item.classList.remove("selected");
              }
            });
            selectedBorderIds = [keepId];
          }
          generateBorderAssignments();
          updatePreview();
          updateApplyButton();
        });
      });

      // Close modal when clicking outside
      if (borderLibraryModal) {
        borderLibraryModal.addEventListener("click", function(e) {
          if (e.target === borderLibraryModal) {
            closeBorderLibrary();
          }
        });
      }

      // Browse button
      if (browseBordersBtn && borderFileInput) {
        browseBordersBtn.addEventListener("click", function() {
          borderFileInput.click();
        });
      }

      // File input change
      if (borderFileInput) {
        borderFileInput.addEventListener("change", function() {
          uploadBorders(this.files);
          this.value = "";
        });
      }

      // Drag and drop
      if (borderUploadZone) {
        borderUploadZone.addEventListener("dragover", function(e) {
          e.preventDefault();
          e.stopPropagation();
          this.classList.add("dragover");
        });

        borderUploadZone.addEventListener("dragleave", function(e) {
          e.preventDefault();
          e.stopPropagation();
          this.classList.remove("dragover");
        });

        borderUploadZone.addEventListener("drop", function(e) {
          e.preventDefault();
          e.stopPropagation();
          this.classList.remove("dragover");
          uploadBorders(e.dataTransfer.files);
        });
      }

      // Track destructive setting changes (require maze regeneration)
      var applyChangesRow = document.getElementById("apply-changes-row");
      var applyMazeChangesBtn = document.getElementById("apply-maze-changes");
      var pathWidthInput = document.getElementById("path-width");
      var pathHeightInput = document.getElementById("path-height");
      var columnsInput = document.getElementById("width");
      var rowsInput = document.getElementById("height");

      // Store initial values to detect changes
      var initialStructureValues = {
        pathWidth: pathWidthInput ? pathWidthInput.value : "",
        pathHeight: pathHeightInput ? pathHeightInput.value : "",
        columns: columnsInput ? columnsInput.value : "",
        rows: rowsInput ? rowsInput.value : "",
      };

      function checkStructureChanges() {
        var changed =
          (pathWidthInput &&
            pathWidthInput.value !== initialStructureValues.pathWidth) ||
          (pathHeightInput &&
            pathHeightInput.value !== initialStructureValues.pathHeight) ||
          (columnsInput &&
            columnsInput.value !== initialStructureValues.columns) ||
          (rowsInput && rowsInput.value !== initialStructureValues.rows);
        if (applyChangesRow) {
          applyChangesRow.style.display = changed ? "flex" : "none";
        }
      }

      function applyMazeChanges() {
        // Check if there are decorations
        var hasDecorations =
          typeof mazeNodes !== "undefined" &&
          mazeNodes.decorations &&
          Object.keys(mazeNodes.decorations).length > 0;

        if (hasDecorations) {
          if (
            !confirm(
              "This will regenerate the maze and remove all decorations. Continue?",
            )
          ) {
            return;
          }
        }

        // Regenerate maze
        if (typeof initMaze === "function") {
          initMaze();
          clearCurrentMap();
        }

        // Update initial values to current
        initialStructureValues.pathWidth = pathWidthInput
          ? pathWidthInput.value
          : "";
        initialStructureValues.pathHeight = pathHeightInput
          ? pathHeightInput.value
          : "";
        initialStructureValues.columns = columnsInput
          ? columnsInput.value
          : "";
        initialStructureValues.rows = rowsInput ? rowsInput.value : "";

        // Hide the apply row
        if (applyChangesRow) {
          applyChangesRow.style.display = "none";
        }
      }

      // Add listeners to destructive inputs
      [pathWidthInput, pathHeightInput, columnsInput, rowsInput].forEach(
        function (input) {
          if (input) {
            input.addEventListener("change", checkStructureChanges);
            input.addEventListener("input", checkStructureChanges);
          }
        },
      );

      if (applyMazeChangesBtn) {
        applyMazeChangesBtn.addEventListener("click", applyMazeChanges);
      }

      // Live update wall size and display scale
      var wallSizeInput = document.getElementById("wall-size");
      var displayScaleInput = document.getElementById("display-scale");

      function updateMazeSize() {
        if (
          typeof mazeNodes === "undefined" ||
          !mazeNodes.matrix ||
          !mazeNodes.matrix.length
        ) {
          return;
        }
        if (wallSizeInput) {
          mazeNodes.wallSize = parseInt(wallSizeInput.value) || 10;
        }
        if (displayScaleInput) {
          mazeNodes.displayScale = parseFloat(displayScaleInput.value) || 1.0;
        }
        mazeNodes.loadTileset().then(function () {
          mazeNodes.draw();
          if (
            typeof TilePlacement !== "undefined" &&
            TilePlacement.saveCanvasState
          ) {
            TilePlacement.saveCanvasState();
          }
        });
      }

      if (wallSizeInput) {
        wallSizeInput.addEventListener("change", updateMazeSize);
        wallSizeInput.addEventListener("input", updateMazeSize);
      }
      if (displayScaleInput) {
        displayScaleInput.addEventListener("change", updateMazeSize);
        displayScaleInput.addEventListener("input", updateMazeSize);
      }

      // Live update entry positions when dropdown or flip checkboxes change
      var entrySelect = document.getElementById("entry");
      var flipStartCheckbox = document.getElementById("flip-start");
      var flipExitCheckbox = document.getElementById("flip-exit");

      function updateEntryPositions() {
        if (
          typeof mazeNodes !== "undefined" &&
          mazeNodes.setEntryType &&
          mazeNodes.matrix &&
          mazeNodes.matrix.length
        ) {
          var entryType = entrySelect ? entrySelect.value : "";
          var flipStart = flipStartCheckbox
            ? flipStartCheckbox.checked
            : false;
          var flipExit = flipExitCheckbox ? flipExitCheckbox.checked : false;
          mazeNodes.setEntryType(entryType, flipStart, flipExit);
          mazeNodes.draw();
          // Update canvas state for decoration preview
          if (
            typeof TilePlacement !== "undefined" &&
            TilePlacement.saveCanvasState
          ) {
            TilePlacement.saveCanvasState();
          }
        }
      }

      if (entrySelect) {
        entrySelect.addEventListener("change", updateEntryPositions);
      }
      if (flipStartCheckbox) {
        flipStartCheckbox.addEventListener("change", updateEntryPositions);
      }
      if (flipExitCheckbox) {
        flipExitCheckbox.addEventListener("change", updateEntryPositions);
      }

      // Live toggle for entry indicators
      var showEntryIndicatorsCheckbox = document.getElementById(
        "show-entry-indicators",
      );
      if (showEntryIndicatorsCheckbox) {
        showEntryIndicatorsCheckbox.addEventListener("change", function () {
          if (
            typeof mazeNodes !== "undefined" &&
            mazeNodes.matrix &&
            mazeNodes.matrix.length
          ) {
            mazeNodes.showEntryIndicators =
              showEntryIndicatorsCheckbox.checked;
            mazeNodes.draw();
          }
        });
      }

      // Live update for entry indicator font size
      var entryIndicatorFontSizeInput = document.getElementById(
        "entry-indicator-font-size",
      );
      if (entryIndicatorFontSizeInput) {
        entryIndicatorFontSizeInput.addEventListener("input", function () {
          if (
            typeof mazeNodes !== "undefined" &&
            mazeNodes.matrix &&
            mazeNodes.matrix.length
          ) {
            mazeNodes.entryIndicatorFontSize =
              parseFloat(entryIndicatorFontSizeInput.value) || 0;
            mazeNodes.draw();
          }
        });
      }

      // Live toggle for show block numbers
      var showBlockNumbersCheckbox =
        document.getElementById("show-block-numbers");
      if (showBlockNumbersCheckbox) {
        showBlockNumbersCheckbox.addEventListener("change", function () {
          if (
            typeof mazeNodes !== "undefined" &&
            mazeNodes.matrix &&
            mazeNodes.matrix.length
          ) {
            mazeNodes.showBlockNumbers = showBlockNumbersCheckbox.checked;
            mazeNodes.draw();
            if (
              typeof TilePlacement !== "undefined" &&
              TilePlacement.saveCanvasState
            ) {
              TilePlacement.saveCanvasState();
            }
          }
        });
      }
    })();
  </script>

  <!-- Floating preview for free-form decoration placement -->
  <div id="freeform-preview">
    <img src="" alt="Preview" />
  </div>

  <!-- Placement scale control (shown during free-form placement mode) -->
  <div class="placement-scale-control" id="placement-scale-control">
    <label>Size:</label>
    <input type="range" id="placement-scale" min="0.01" max="0.5" step="0.01" value="0.04" />
    <span class="scale-value" id="placement-scale-value">0.04x</span>
    <span class="hint">Click to place</span>
  </div>

  <!-- Toast notifications container -->
  <div class="toast-container" id="toast-container"></div>
</body>

</html>
